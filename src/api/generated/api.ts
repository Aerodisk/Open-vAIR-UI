/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface AttachDisksInner
 */
export interface AttachDisksInner {
  /**
   *
   * @type {string}
   * @memberof AttachDisksInner
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof AttachDisksInner
   */
  emulation?: AttachDisksInnerEmulationEnum
  /**
   *
   * @type {string}
   * @memberof AttachDisksInner
   */
  format?: AttachDisksInnerFormatEnum
  /**
   *
   * @type {QOS}
   * @memberof AttachDisksInner
   */
  qos: QOS
  /**
   *
   * @type {number}
   * @memberof AttachDisksInner
   */
  boot_order: number
  /**
   *
   * @type {number}
   * @memberof AttachDisksInner
   */
  order: number
  /**
   *
   * @type {boolean}
   * @memberof AttachDisksInner
   */
  read_only?: boolean
  /**
   *
   * @type {string}
   * @memberof AttachDisksInner
   */
  volume_id: string
  /**
   *
   * @type {string}
   * @memberof AttachDisksInner
   */
  image_id: string
  /**
   *
   * @type {string}
   * @memberof AttachDisksInner
   */
  storage_id: string
  /**
   *
   * @type {number}
   * @memberof AttachDisksInner
   */
  size: number
}

export const AttachDisksInnerEmulationEnum = {
  Virtio: 'virtio',
  Ide: 'ide',
  Scsi: 'scsi',
} as const

export type AttachDisksInnerEmulationEnum =
  (typeof AttachDisksInnerEmulationEnum)[keyof typeof AttachDisksInnerEmulationEnum]
export const AttachDisksInnerFormatEnum = {
  Qcow2: 'qcow2',
  Raw: 'raw',
} as const

export type AttachDisksInnerFormatEnum = (typeof AttachDisksInnerFormatEnum)[keyof typeof AttachDisksInnerFormatEnum]

/**
 *
 * @export
 * @interface AttachImageInfo
 */
export interface AttachImageInfo {
  /**
   *
   * @type {string}
   * @memberof AttachImageInfo
   */
  path: string
  /**
   *
   * @type {number}
   * @memberof AttachImageInfo
   */
  size: number
  /**
   *
   * @type {string}
   * @memberof AttachImageInfo
   */
  provisioning?: string
}
/**
 *
 * @export
 * @interface AttachVolumeInfo
 */
export interface AttachVolumeInfo {
  /**
   *
   * @type {string}
   * @memberof AttachVolumeInfo
   */
  path?: string
  /**
   *
   * @type {number}
   * @memberof AttachVolumeInfo
   */
  size: number
  /**
   *
   * @type {string}
   * @memberof AttachVolumeInfo
   */
  provisioning: string
}
/**
 *
 * @export
 * @interface AutoCreateVolume
 */
export interface AutoCreateVolume {
  /**
   *
   * @type {string}
   * @memberof AutoCreateVolume
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof AutoCreateVolume
   */
  emulation?: AutoCreateVolumeEmulationEnum
  /**
   *
   * @type {string}
   * @memberof AutoCreateVolume
   */
  format?: AutoCreateVolumeFormatEnum
  /**
   *
   * @type {QOS}
   * @memberof AutoCreateVolume
   */
  qos: QOS
  /**
   *
   * @type {number}
   * @memberof AutoCreateVolume
   */
  boot_order: number
  /**
   *
   * @type {number}
   * @memberof AutoCreateVolume
   */
  order: number
  /**
   *
   * @type {boolean}
   * @memberof AutoCreateVolume
   */
  read_only?: boolean
  /**
   *
   * @type {string}
   * @memberof AutoCreateVolume
   */
  storage_id: string
  /**
   *
   * @type {number}
   * @memberof AutoCreateVolume
   */
  size: number
}

export const AutoCreateVolumeEmulationEnum = {
  Virtio: 'virtio',
  Ide: 'ide',
  Scsi: 'scsi',
} as const

export type AutoCreateVolumeEmulationEnum =
  (typeof AutoCreateVolumeEmulationEnum)[keyof typeof AutoCreateVolumeEmulationEnum]
export const AutoCreateVolumeFormatEnum = {
  Qcow2: 'qcow2',
  Raw: 'raw',
} as const

export type AutoCreateVolumeFormatEnum = (typeof AutoCreateVolumeFormatEnum)[keyof typeof AutoCreateVolumeFormatEnum]

/**
 * Represents bandwidth usage data.  Attributes:     read (float): The amount of data read in bandwidth usage.     write (float): The amount of data written in bandwidth usage.     date (int): The timestamp of the bandwidth usage data.
 * @export
 * @interface BandWithData
 */
export interface BandWithData {
  /**
   *
   * @type {number}
   * @memberof BandWithData
   */
  read: number
  /**
   *
   * @type {number}
   * @memberof BandWithData
   */
  write: number
  /**
   *
   * @type {number}
   * @memberof BandWithData
   */
  date: number
}
/**
 * Schema for creating a new bridge.  Attributes:     ip (Optional[str]): The IP address of the bridge.     name (str): The name of the bridge.     type (str): The type of the bridge (e.g., OVS, Linux bridge).     interfaces (List[Interface]): The list of interfaces associated with         the bridge.     status (Optional[str]): The status of the bridge.
 * @export
 * @interface BridgeCreate
 */
export interface BridgeCreate {
  /**
   *
   * @type {string}
   * @memberof BridgeCreate
   */
  ip?: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreate
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreate
   */
  type: string
  /**
   *
   * @type {Array<OpenvairModulesNetworkEntrypointsSchemasInterface>}
   * @memberof BridgeCreate
   */
  interfaces: Array<OpenvairModulesNetworkEntrypointsSchemasInterface>
  /**
   *
   * @type {string}
   * @memberof BridgeCreate
   */
  status?: string
}
/**
 * Schema for the response after creating a bridge.  Attributes:     id (str): The unique identifier of the bridge.     ip (str): The IP address of the bridge.     name (str): The name of the bridge.     gateway (str): The gateway IP address of the bridge.     power_state (str): The power state of the bridge.     mac (str): The MAC address of the bridge.     netmask (Optional[str]): The netmask of the bridge.     inf_type (str): The type of the bridge.     status (str): The status of the bridge.     interface_extra_specs (InterfaceExtraSpecs): Additional specifications         for the bridge\'s interface.
 * @export
 * @interface BridgeCreateResponse
 */
export interface BridgeCreateResponse {
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  gateway: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  power_state: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  mac: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  netmask?: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  inf_type: string
  /**
   *
   * @type {string}
   * @memberof BridgeCreateResponse
   */
  status: string
  /**
   *
   * @type {InterfaceExtraSpecs}
   * @memberof BridgeCreateResponse
   */
  interface_extra_specs: InterfaceExtraSpecs
}
/**
 * Schema for deleting a bridge.  Attributes:     data (List[Interface]): The list of interfaces to delete.
 * @export
 * @interface BridgeDelete
 */
export interface BridgeDelete {
  /**
   *
   * @type {Array<OpenvairModulesNetworkEntrypointsSchemasInterface>}
   * @memberof BridgeDelete
   */
  data: Array<OpenvairModulesNetworkEntrypointsSchemasInterface>
}
/**
 * Pydantic model representing a CSV file response.  Attributes:     filename (str): The name of the CSV file.     content_type (str): The content type of the file, typically \'text/csv\'.     content (List[Event]): A list of events to be included in the CSV file.
 * @export
 * @interface CSVResponse
 */
export interface CSVResponse {
  /**
   *
   * @type {string}
   * @memberof CSVResponse
   */
  filename: string
  /**
   *
   * @type {string}
   * @memberof CSVResponse
   */
  content_type: string
  /**
   *
   * @type {Array<Event>}
   * @memberof CSVResponse
   */
  content: Array<Event>
}
/**
 *
 * @export
 * @interface Cpu
 */
export interface Cpu {
  /**
   *
   * @type {number}
   * @memberof Cpu
   */
  cores?: number
  /**
   *
   * @type {number}
   * @memberof Cpu
   */
  threads?: number
  /**
   *
   * @type {number}
   * @memberof Cpu
   */
  sockets?: number
  /**
   *
   * @type {string}
   * @memberof Cpu
   */
  model?: CpuModelEnum
  /**
   *
   * @type {string}
   * @memberof Cpu
   */
  type?: CpuTypeEnum
  /**
   *
   * @type {number}
   * @memberof Cpu
   */
  vcpu?: number
}

export const CpuModelEnum = {
  Host: 'host',
} as const

export type CpuModelEnum = (typeof CpuModelEnum)[keyof typeof CpuModelEnum]
export const CpuTypeEnum = {
  Static: 'static',
  Dynamic: 'dynamic',
} as const

export type CpuTypeEnum = (typeof CpuTypeEnum)[keyof typeof CpuTypeEnum]

/**
 * Represents CPU usage data.  Attributes:     count (int): The number of CPU cores.     percentage (float): The percentage of CPU usage.
 * @export
 * @interface CpuData
 */
export interface CpuData {
  /**
   *
   * @type {number}
   * @memberof CpuData
   */
  count: number
  /**
   *
   * @type {number}
   * @memberof CpuData
   */
  percentage: number
}
/**
 *
 * @export
 * @interface CreateLocalPartition
 */
export interface CreateLocalPartition {
  /**
   *
   * @type {string}
   * @memberof CreateLocalPartition
   */
  local_disk_path: string
  /**
   *
   * @type {string}
   * @memberof CreateLocalPartition
   */
  storage_type: CreateLocalPartitionStorageTypeEnum
  /**
   *
   * @type {number}
   * @memberof CreateLocalPartition
   */
  size_value: number
  /**
   *
   * @type {string}
   * @memberof CreateLocalPartition
   */
  size_unit: CreateLocalPartitionSizeUnitEnum
}

export const CreateLocalPartitionStorageTypeEnum = {
  LocalPartition: 'local_partition',
} as const

export type CreateLocalPartitionStorageTypeEnum =
  (typeof CreateLocalPartitionStorageTypeEnum)[keyof typeof CreateLocalPartitionStorageTypeEnum]
export const CreateLocalPartitionSizeUnitEnum = {
  B: 'B',
} as const

export type CreateLocalPartitionSizeUnitEnum =
  (typeof CreateLocalPartitionSizeUnitEnum)[keyof typeof CreateLocalPartitionSizeUnitEnum]

/**
 *
 * @export
 * @interface CreateStorage
 */
export interface CreateStorage {
  /**
   *
   * @type {string}
   * @memberof CreateStorage
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateStorage
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof CreateStorage
   */
  storage_type: CreateStorageStorageTypeEnum
  /**
   *
   * @type {Specs}
   * @memberof CreateStorage
   */
  specs: Specs
}

export const CreateStorageStorageTypeEnum = {
  Nfs: 'nfs',
  Localfs: 'localfs',
} as const

export type CreateStorageStorageTypeEnum =
  (typeof CreateStorageStorageTypeEnum)[keyof typeof CreateStorageStorageTypeEnum]

/**
 *
 * @export
 * @interface CreateVirtualMachine
 */
export interface CreateVirtualMachine {
  /**
   *
   * @type {string}
   * @memberof CreateVirtualMachine
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateVirtualMachine
   */
  description?: string
  /**
   *
   * @type {Os}
   * @memberof CreateVirtualMachine
   */
  os: Os
  /**
   *
   * @type {Cpu}
   * @memberof CreateVirtualMachine
   */
  cpu: Cpu
  /**
   *
   * @type {RAM}
   * @memberof CreateVirtualMachine
   */
  ram: RAM
  /**
   *
   * @type {GraphicInterfaceBase}
   * @memberof CreateVirtualMachine
   */
  graphic_interface: GraphicInterfaceBase
  /**
   *
   * @type {CreateVmDisks}
   * @memberof CreateVirtualMachine
   */
  disks: CreateVmDisks
  /**
   *
   * @type {Array<VirtualInterface>}
   * @memberof CreateVirtualMachine
   */
  virtual_interfaces: Array<VirtualInterface>
}
/**
 *
 * @export
 * @interface CreateVmDisks
 */
export interface CreateVmDisks {
  /**
   *
   * @type {Array<AttachDisksInner>}
   * @memberof CreateVmDisks
   */
  attach_disks: Array<AttachDisksInner>
}
/**
 *
 * @export
 * @interface CreateVolume
 */
export interface CreateVolume {
  /**
   *
   * @type {string}
   * @memberof CreateVolume
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateVolume
   */
  description: string
  /**
   *
   * @type {string}
   * @memberof CreateVolume
   */
  storage_id: string
  /**
   *
   * @type {string}
   * @memberof CreateVolume
   */
  format: CreateVolumeFormatEnum
  /**
   *
   * @type {number}
   * @memberof CreateVolume
   */
  size?: number
  /**
   *
   * @type {boolean}
   * @memberof CreateVolume
   */
  read_only?: boolean
}

export const CreateVolumeFormatEnum = {
  Qcow2: 'qcow2',
  Raw: 'raw',
} as const

export type CreateVolumeFormatEnum = (typeof CreateVolumeFormatEnum)[keyof typeof CreateVolumeFormatEnum]

/**
 *
 * @export
 * @interface DeleteLocalPartition
 */
export interface DeleteLocalPartition {
  /**
   *
   * @type {string}
   * @memberof DeleteLocalPartition
   */
  storage_type: DeleteLocalPartitionStorageTypeEnum
  /**
   *
   * @type {string}
   * @memberof DeleteLocalPartition
   */
  local_disk_path: string
  /**
   *
   * @type {string}
   * @memberof DeleteLocalPartition
   */
  partition_number: string
}

export const DeleteLocalPartitionStorageTypeEnum = {
  LocalPartition: 'local_partition',
} as const

export type DeleteLocalPartitionStorageTypeEnum =
  (typeof DeleteLocalPartitionStorageTypeEnum)[keyof typeof DeleteLocalPartitionStorageTypeEnum]

/**
 *
 * @export
 * @interface DetachDisk
 */
export interface DetachDisk {
  /**
   *
   * @type {number}
   * @memberof DetachDisk
   */
  id: number
}
/**
 *
 * @export
 * @interface DetachImage
 */
export interface DetachImage {
  /**
   *
   * @type {string}
   * @memberof DetachImage
   */
  vm_id: string
}
/**
 *
 * @export
 * @interface DetachVirtualInterface
 */
export interface DetachVirtualInterface {
  /**
   *
   * @type {number}
   * @memberof DetachVirtualInterface
   */
  id: number
}
/**
 *
 * @export
 * @interface DetachVolume
 */
export interface DetachVolume {
  /**
   *
   * @type {string}
   * @memberof DetachVolume
   */
  vm_id: string
}
/**
 * Pydantic model representing a download response containing a CSV file.  Attributes:     file (CSVResponse): The CSV file response containing event data.
 * @export
 * @interface DownloadResponse
 */
export interface DownloadResponse {
  /**
   *
   * @type {CSVResponse}
   * @memberof DownloadResponse
   */
  file: CSVResponse
}
/**
 *
 * @export
 * @interface EditDisk
 */
export interface EditDisk {
  /**
   *
   * @type {string}
   * @memberof EditDisk
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EditDisk
   */
  emulation?: EditDiskEmulationEnum
  /**
   *
   * @type {string}
   * @memberof EditDisk
   */
  format?: EditDiskFormatEnum
  /**
   *
   * @type {QOS}
   * @memberof EditDisk
   */
  qos: QOS
  /**
   *
   * @type {number}
   * @memberof EditDisk
   */
  boot_order: number
  /**
   *
   * @type {number}
   * @memberof EditDisk
   */
  order: number
  /**
   *
   * @type {boolean}
   * @memberof EditDisk
   */
  read_only?: boolean
  /**
   *
   * @type {number}
   * @memberof EditDisk
   */
  id: number
}

export const EditDiskEmulationEnum = {
  Virtio: 'virtio',
  Ide: 'ide',
  Scsi: 'scsi',
} as const

export type EditDiskEmulationEnum = (typeof EditDiskEmulationEnum)[keyof typeof EditDiskEmulationEnum]
export const EditDiskFormatEnum = {
  Qcow2: 'qcow2',
  Raw: 'raw',
} as const

export type EditDiskFormatEnum = (typeof EditDiskFormatEnum)[keyof typeof EditDiskFormatEnum]

/**
 *
 * @export
 * @interface EditVirtualInterface
 */
export interface EditVirtualInterface {
  /**
   *
   * @type {string}
   * @memberof EditVirtualInterface
   */
  mode?: EditVirtualInterfaceModeEnum
  /**
   *
   * @type {string}
   * @memberof EditVirtualInterface
   */
  portgroup?: string
  /**
   *
   * @type {string}
   * @memberof EditVirtualInterface
   */
  interface: string
  /**
   *
   * @type {string}
   * @memberof EditVirtualInterface
   */
  mac?: string
  /**
   *
   * @type {string}
   * @memberof EditVirtualInterface
   */
  model?: EditVirtualInterfaceModelEnum
  /**
   *
   * @type {number}
   * @memberof EditVirtualInterface
   */
  order?: number
  /**
   *
   * @type {number}
   * @memberof EditVirtualInterface
   */
  id: number
}

export const EditVirtualInterfaceModeEnum = {
  Bridge: 'bridge',
  Nat: 'nat',
  Default: 'default',
  Isolated: 'isolated',
  Vepa: 'vepa',
  User: 'user',
  VirtualNetwork: 'virtual_network',
} as const

export type EditVirtualInterfaceModeEnum =
  (typeof EditVirtualInterfaceModeEnum)[keyof typeof EditVirtualInterfaceModeEnum]
export const EditVirtualInterfaceModelEnum = {
  Virtio: 'virtio',
} as const

export type EditVirtualInterfaceModelEnum =
  (typeof EditVirtualInterfaceModelEnum)[keyof typeof EditVirtualInterfaceModelEnum]

/**
 *
 * @export
 * @interface EditVirtualInterfaces
 */
export interface EditVirtualInterfaces {
  /**
   *
   * @type {Array<VirtualInterface>}
   * @memberof EditVirtualInterfaces
   */
  new_virtual_interfaces: Array<VirtualInterface>
  /**
   *
   * @type {Array<DetachVirtualInterface>}
   * @memberof EditVirtualInterfaces
   */
  detach_virtual_interfaces: Array<DetachVirtualInterface>
  /**
   *
   * @type {Array<EditVirtualInterface>}
   * @memberof EditVirtualInterfaces
   */
  edit_virtual_interfaces: Array<EditVirtualInterface>
}
/**
 *
 * @export
 * @interface EditVm
 */
export interface EditVm {
  /**
   *
   * @type {string}
   * @memberof EditVm
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof EditVm
   */
  description: string
  /**
   *
   * @type {Cpu}
   * @memberof EditVm
   */
  cpu: Cpu
  /**
   *
   * @type {RAM}
   * @memberof EditVm
   */
  ram: RAM
  /**
   *
   * @type {Os}
   * @memberof EditVm
   */
  os: Os
  /**
   *
   * @type {GraphicInterfaceBase}
   * @memberof EditVm
   */
  graphic_interface: GraphicInterfaceBase
  /**
   *
   * @type {EditVmDisks}
   * @memberof EditVm
   */
  disks: EditVmDisks
  /**
   *
   * @type {EditVirtualInterfaces}
   * @memberof EditVm
   */
  virtual_interfaces: EditVirtualInterfaces
}
/**
 *
 * @export
 * @interface EditVmDisks
 */
export interface EditVmDisks {
  /**
   *
   * @type {Array<AttachDisksInner>}
   * @memberof EditVmDisks
   */
  attach_disks: Array<AttachDisksInner>
  /**
   *
   * @type {Array<DetachDisk>}
   * @memberof EditVmDisks
   */
  detach_disks: Array<DetachDisk>
  /**
   *
   * @type {Array<EditDisk>}
   * @memberof EditVmDisks
   */
  edit_disks: Array<EditDisk>
}
/**
 *
 * @export
 * @interface EditVolume
 */
export interface EditVolume {
  /**
   *
   * @type {string}
   * @memberof EditVolume
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof EditVolume
   */
  description: string
  /**
   *
   * @type {boolean}
   * @memberof EditVolume
   */
  read_only?: boolean
}
/**
 * Represents an error response.  Attributes:     details (str): Details of the error.
 * @export
 * @interface ErrorResponseModel
 */
export interface ErrorResponseModel {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseModel
   */
  details: string
}
/**
 * Pydantic model representing an event.  Attributes:     id (int): Unique identifier of the event.     module (str): Name of the module where the event originated.     object_id (str): ID of the related object.     user_id (str): ID of the user who created the event.     event (str): Description of the event.     timestamp (int): Timestamp of the event occurrence.     information (Optional[str]): Additional information about the event.
 * @export
 * @interface Event
 */
export interface Event {
  /**
   *
   * @type {number}
   * @memberof Event
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof Event
   */
  module: string
  /**
   *
   * @type {string}
   * @memberof Event
   */
  object_id: string
  /**
   *
   * @type {string}
   * @memberof Event
   */
  user_id: string
  /**
   *
   * @type {string}
   * @memberof Event
   */
  event: string
  /**
   *
   * @type {number}
   * @memberof Event
   */
  timestamp: number
  /**
   *
   * @type {string}
   * @memberof Event
   */
  information?: string
}
/**
 *
 * @export
 * @interface ExtendVolume
 */
export interface ExtendVolume {
  /**
   *
   * @type {number}
   * @memberof ExtendVolume
   */
  new_size?: number
}
/**
 *
 * @export
 * @interface GraphicInterfaceBase
 */
export interface GraphicInterfaceBase {
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceBase
   */
  login?: string
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceBase
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceBase
   */
  connect_type?: GraphicInterfaceBaseConnectTypeEnum
}

export const GraphicInterfaceBaseConnectTypeEnum = {
  Vnc: 'vnc',
  Spice: 'spice',
} as const

export type GraphicInterfaceBaseConnectTypeEnum =
  (typeof GraphicInterfaceBaseConnectTypeEnum)[keyof typeof GraphicInterfaceBaseConnectTypeEnum]

/**
 *
 * @export
 * @interface GraphicInterfaceInfo
 */
export interface GraphicInterfaceInfo {
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceInfo
   */
  login?: string
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceInfo
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceInfo
   */
  connect_type?: GraphicInterfaceInfoConnectTypeEnum
  /**
   *
   * @type {string}
   * @memberof GraphicInterfaceInfo
   */
  url?: string
}

export const GraphicInterfaceInfoConnectTypeEnum = {
  Vnc: 'vnc',
  Spice: 'spice',
} as const

export type GraphicInterfaceInfoConnectTypeEnum =
  (typeof GraphicInterfaceInfoConnectTypeEnum)[keyof typeof GraphicInterfaceInfoConnectTypeEnum]

/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>
}
/**
 * Represents IO latency data.  Attributes:     wait (float): The wait time for IO operations.     date (int): The timestamp of the IO latency data.
 * @export
 * @interface IOLatency
 */
export interface IOLatency {
  /**
   *
   * @type {number}
   * @memberof IOLatency
   */
  wait: number
  /**
   *
   * @type {number}
   * @memberof IOLatency
   */
  date: number
}
/**
 * Represents an IQN (iSCSI Qualified Name).  Attributes:     iqn (str): The IQN.
 * @export
 * @interface IQN
 */
export interface IQN {
  /**
   *
   * @type {string}
   * @memberof IQN
   */
  iqn: string
}
/**
 *
 * @export
 * @interface Image
 */
export interface Image {
  /**
   *
   * @type {string}
   * @memberof Image
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Image
   */
  name: string
  /**
   *
   * @type {number}
   * @memberof Image
   */
  size?: number
  /**
   *
   * @type {string}
   * @memberof Image
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof Image
   */
  status: string
  /**
   *
   * @type {string}
   * @memberof Image
   */
  information?: string
  /**
   *
   * @type {string}
   * @memberof Image
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof Image
   */
  storage_id: string
  /**
   *
   * @type {string}
   * @memberof Image
   */
  user_id?: string
  /**
   *
   * @type {Array<OpenvairModulesImageEntrypointsSchemasAttachment>}
   * @memberof Image
   */
  attachments?: Array<OpenvairModulesImageEntrypointsSchemasAttachment>
}
/**
 * Represents a block device interface that has been deleted.  Attributes:     inf_type (str): The type of the block device interface.     ip (str): The IP address of the block device interface.
 * @export
 * @interface InterfaceDeleted
 */
export interface InterfaceDeleted {
  /**
   *
   * @type {string}
   * @memberof InterfaceDeleted
   */
  inf_type: string
  /**
   *
   * @type {string}
   * @memberof InterfaceDeleted
   */
  ip: string
}
/**
 * Additional specifications for network interfaces.  Attributes:     slot_port (Optional[str]): The slot and port information.     duplex (Optional[str]): The duplex mode of the interface.
 * @export
 * @interface InterfaceExtraSpecs
 */
export interface InterfaceExtraSpecs {
  /**
   *
   * @type {string}
   * @memberof InterfaceExtraSpecs
   */
  slot_port?: string
  /**
   *
   * @type {string}
   * @memberof InterfaceExtraSpecs
   */
  duplex?: string
}
/**
 * Represents a block device interface with login status.  Attributes:     id (str): The ID of the block device interface.     status (str): The login status of the block device interface.
 * @export
 * @interface InterfaceLogin
 */
export interface InterfaceLogin {
  /**
   *
   * @type {string}
   * @memberof InterfaceLogin
   */
  inf_type: string
  /**
   *
   * @type {string}
   * @memberof InterfaceLogin
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof InterfaceLogin
   */
  port?: string
  /**
   *
   * @type {string}
   * @memberof InterfaceLogin
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof InterfaceLogin
   */
  status: string
}
/**
 * Represents IOPS (Input/Output Operations Per Second) data.  Attributes:     input (int): The number of input operations.     output (int): The number of output operations.     date (int): The timestamp of the IOPS data.
 * @export
 * @interface IopsData
 */
export interface IopsData {
  /**
   *
   * @type {number}
   * @memberof IopsData
   */
  input: number
  /**
   *
   * @type {number}
   * @memberof IopsData
   */
  output: number
  /**
   *
   * @type {number}
   * @memberof IopsData
   */
  date: number
}
/**
 *
 * @export
 * @interface ListOfLocalDisks
 */
export interface ListOfLocalDisks {
  /**
   *
   * @type {Array<LocalDisk>}
   * @memberof ListOfLocalDisks
   */
  disks: Array<LocalDisk>
}
/**
 * Represents a response containing a list of virtual networks.  Attributes:     virtual_networks (List[VirtualNetworkResponse]): List of virtual         networks.
 * @export
 * @interface ListOfVirtualNetworksResponse
 */
export interface ListOfVirtualNetworksResponse {
  /**
   *
   * @type {Array<VirtualNetworkResponse>}
   * @memberof ListOfVirtualNetworksResponse
   */
  virtual_networks: Array<VirtualNetworkResponse>
}
/**
 *
 * @export
 * @interface LocalDisk
 */
export interface LocalDisk {
  /**
   *
   * @type {string}
   * @memberof LocalDisk
   */
  path: string
  /**
   *
   * @type {number}
   * @memberof LocalDisk
   */
  size: number
  /**
   *
   * @type {string}
   * @memberof LocalDisk
   */
  mountpoint?: string
  /**
   *
   * @type {string}
   * @memberof LocalDisk
   */
  fs_uuid?: string
  /**
   *
   * @type {string}
   * @memberof LocalDisk
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof LocalDisk
   */
  fstype?: string
  /**
   *
   * @type {string}
   * @memberof LocalDisk
   */
  parent?: string
}
/**
 *
 * @export
 * @interface LocalFSStorageExtraSpecsCreate
 */
export interface LocalFSStorageExtraSpecsCreate {
  /**
   *
   * @type {string}
   * @memberof LocalFSStorageExtraSpecsCreate
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof LocalFSStorageExtraSpecsCreate
   */
  fs_type: LocalFSStorageExtraSpecsCreateFsTypeEnum
}

export const LocalFSStorageExtraSpecsCreateFsTypeEnum = {
  Xfs: 'xfs',
  Ext4: 'ext4',
} as const

export type LocalFSStorageExtraSpecsCreateFsTypeEnum =
  (typeof LocalFSStorageExtraSpecsCreateFsTypeEnum)[keyof typeof LocalFSStorageExtraSpecsCreateFsTypeEnum]

/**
 *
 * @export
 * @interface LocalFSStorageExtraSpecsInfo
 */
export interface LocalFSStorageExtraSpecsInfo {
  /**
   *
   * @type {string}
   * @memberof LocalFSStorageExtraSpecsInfo
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof LocalFSStorageExtraSpecsInfo
   */
  fs_type: LocalFSStorageExtraSpecsInfoFsTypeEnum
  /**
   *
   * @type {string}
   * @memberof LocalFSStorageExtraSpecsInfo
   */
  mount_point?: string
}

export const LocalFSStorageExtraSpecsInfoFsTypeEnum = {
  Xfs: 'xfs',
  Ext4: 'ext4',
} as const

export type LocalFSStorageExtraSpecsInfoFsTypeEnum =
  (typeof LocalFSStorageExtraSpecsInfoFsTypeEnum)[keyof typeof LocalFSStorageExtraSpecsInfoFsTypeEnum]

/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 * Represents memory usage data.  Attributes:     value (int): The total memory value.     used (int): The amount of used memory.     available (int): The amount of available memory.     percentage (float): The percentage of memory usage.
 * @export
 * @interface MemoryData
 */
export interface MemoryData {
  /**
   *
   * @type {number}
   * @memberof MemoryData
   */
  value: number
  /**
   *
   * @type {number}
   * @memberof MemoryData
   */
  used: number
  /**
   *
   * @type {number}
   * @memberof MemoryData
   */
  available: number
  /**
   *
   * @type {number}
   * @memberof MemoryData
   */
  percentage: number
}
/**
 *
 * @export
 * @interface NfsStorageExtraSpecsCreate
 */
export interface NfsStorageExtraSpecsCreate {
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsCreate
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsCreate
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsCreate
   */
  mount_version?: string
}
/**
 *
 * @export
 * @interface NfsStorageExtraSpecsInfo
 */
export interface NfsStorageExtraSpecsInfo {
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsInfo
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsInfo
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsInfo
   */
  mount_version?: string
  /**
   *
   * @type {string}
   * @memberof NfsStorageExtraSpecsInfo
   */
  mount_point?: string
}
/**
 * Aggregates node metrics into a comprehensive representation.  Attributes:     cpu (CpuData): CPU usage data.     memory (MemoryData): Memory usage data.     storage (StoragesData): Storage usage data.     iops (IopsData): IOPS data.     io_latency (IOLatency): IO latency data.     bandwith_data (BandWithData): Bandwidth usage data.     disk_data (DiskInfo): Disk read/write data.
 * @export
 * @interface NodeInfo
 */
export interface NodeInfo {
  /**
   *
   * @type {CpuData}
   * @memberof NodeInfo
   */
  cpu: CpuData
  /**
   *
   * @type {MemoryData}
   * @memberof NodeInfo
   */
  memory: MemoryData
  /**
   *
   * @type {StoragesData}
   * @memberof NodeInfo
   */
  storage: StoragesData
  /**
   *
   * @type {IopsData}
   * @memberof NodeInfo
   */
  iops: IopsData
  /**
   *
   * @type {IOLatency}
   * @memberof NodeInfo
   */
  io_latency: IOLatency
  /**
   *
   * @type {BandWithData}
   * @memberof NodeInfo
   */
  bandwith_data: BandWithData
  /**
   *
   * @type {OpenvairModulesDashboardEntrypointsSchemasDiskInfo}
   * @memberof NodeInfo
   */
  disk_data: OpenvairModulesDashboardEntrypointsSchemasDiskInfo
}
/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  msg_type: string
  /**
   *
   * @type {Array<string>}
   * @memberof Notification
   */
  recipients?: Array<string>
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  subject: string
  /**
   *
   * @type {string}
   * @memberof Notification
   */
  message: string
}
/**
 * Represents general information about a block device interface.  Attributes:     inf_type (str): The type of the block device interface.     ip (str): The IP address of the block device interface.     port (Optional[str]): The port number of the block device interface.
 * @export
 * @interface OpenvairModulesBlockDeviceEntrypointsSchemasInterface
 */
export interface OpenvairModulesBlockDeviceEntrypointsSchemasInterface {
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesBlockDeviceEntrypointsSchemasInterface
   */
  inf_type: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesBlockDeviceEntrypointsSchemasInterface
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesBlockDeviceEntrypointsSchemasInterface
   */
  port?: string
}
/**
 * Represents disk read/write data.  Attributes:     read (float): The amount of data read from the disk.     write (float): The amount of data written to the disk.     date (int): The timestamp of the disk data.
 * @export
 * @interface OpenvairModulesDashboardEntrypointsSchemasDiskInfo
 */
export interface OpenvairModulesDashboardEntrypointsSchemasDiskInfo {
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesDashboardEntrypointsSchemasDiskInfo
   */
  read: number
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesDashboardEntrypointsSchemasDiskInfo
   */
  write: number
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesDashboardEntrypointsSchemasDiskInfo
   */
  date: number
}
/**
 *
 * @export
 * @interface OpenvairModulesImageEntrypointsSchemasAttachImage
 */
export interface OpenvairModulesImageEntrypointsSchemasAttachImage {
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesImageEntrypointsSchemasAttachImage
   */
  vm_id: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesImageEntrypointsSchemasAttachImage
   */
  target?: string
}
/**
 *
 * @export
 * @interface OpenvairModulesImageEntrypointsSchemasAttachment
 */
export interface OpenvairModulesImageEntrypointsSchemasAttachment {
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesImageEntrypointsSchemasAttachment
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesImageEntrypointsSchemasAttachment
   */
  vm_id: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesImageEntrypointsSchemasAttachment
   */
  target?: string
}
/**
 * Schema representing a network interface.  Attributes:     id (str): The unique identifier of the interface.     name (str): The name of the interface.     mac (str): The MAC address of the interface.     ip (Optional[str]): The IP address of the interface.     netmask (Optional[str]): The netmask of the interface.     inf_type (str): The type of the interface (e.g., physical, virtual).     power_state (str): The power state of the interface (e.g., on, off).     status (Optional[str]): The status of the interface.     mtu (Optional[int]): The Maximum Transmission Unit size.     speed (Optional[int]): The speed of the interface.     interface_extra_specs (Optional[InterfaceExtraSpecs]): Additional         specifications for the interface.
 * @export
 * @interface OpenvairModulesNetworkEntrypointsSchemasInterface
 */
export interface OpenvairModulesNetworkEntrypointsSchemasInterface {
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  mac: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  ip?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  netmask?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  inf_type: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  power_state: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  status?: string
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  mtu?: number
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  speed?: number
  /**
   *
   * @type {InterfaceExtraSpecs}
   * @memberof OpenvairModulesNetworkEntrypointsSchemasInterface
   */
  interface_extra_specs?: InterfaceExtraSpecs
}
/**
 *
 * @export
 * @interface OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
 */
export interface OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage {
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  emulation?: OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageEmulationEnum
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  format?: OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageFormatEnum
  /**
   *
   * @type {QOS}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  qos: QOS
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  boot_order: number
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  order: number
  /**
   *
   * @type {boolean}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  read_only?: boolean
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImage
   */
  image_id: string
}

export const OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageEmulationEnum = {
  Virtio: 'virtio',
  Ide: 'ide',
  Scsi: 'scsi',
} as const

export type OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageEmulationEnum =
  (typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageEmulationEnum)[keyof typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageEmulationEnum]
export const OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageFormatEnum = {
  Qcow2: 'qcow2',
  Raw: 'raw',
} as const

export type OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageFormatEnum =
  (typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageFormatEnum)[keyof typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachImageFormatEnum]

/**
 *
 * @export
 * @interface OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
 */
export interface OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume {
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  emulation?: OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeEmulationEnum
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  format?: OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeFormatEnum
  /**
   *
   * @type {QOS}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  qos: QOS
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  boot_order: number
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  order: number
  /**
   *
   * @type {boolean}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  read_only?: boolean
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolume
   */
  volume_id: string
}

export const OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeEmulationEnum = {
  Virtio: 'virtio',
  Ide: 'ide',
  Scsi: 'scsi',
} as const

export type OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeEmulationEnum =
  (typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeEmulationEnum)[keyof typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeEmulationEnum]
export const OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeFormatEnum = {
  Qcow2: 'qcow2',
  Raw: 'raw',
} as const

export type OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeFormatEnum =
  (typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeFormatEnum)[keyof typeof OpenvairModulesVirtualMachinesEntrypointsSchemasAttachVolumeFormatEnum]

/**
 *
 * @export
 * @interface OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
 */
export interface OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo {
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  emulation?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  format?: string
  /**
   *
   * @type {QOS}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  qos?: QOS
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  boot_order?: number
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  order?: number
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  path?: string
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  size?: number
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  provisioning?: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  disk_id?: string
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  type?: number
  /**
   *
   * @type {boolean}
   * @memberof OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo
   */
  read_only?: boolean
}
/**
 *
 * @export
 * @interface OpenvairModulesVolumeEntrypointsSchemasAttachVolume
 */
export interface OpenvairModulesVolumeEntrypointsSchemasAttachVolume {
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVolumeEntrypointsSchemasAttachVolume
   */
  vm_id: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVolumeEntrypointsSchemasAttachVolume
   */
  target?: string
}
/**
 *
 * @export
 * @interface OpenvairModulesVolumeEntrypointsSchemasAttachment
 */
export interface OpenvairModulesVolumeEntrypointsSchemasAttachment {
  /**
   *
   * @type {number}
   * @memberof OpenvairModulesVolumeEntrypointsSchemasAttachment
   */
  id: number
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVolumeEntrypointsSchemasAttachment
   */
  vm_id: string
  /**
   *
   * @type {string}
   * @memberof OpenvairModulesVolumeEntrypointsSchemasAttachment
   */
  target?: string
}
/**
 *
 * @export
 * @interface Os
 */
export interface Os {
  /**
   *
   * @type {string}
   * @memberof Os
   */
  os_type?: string
  /**
   *
   * @type {string}
   * @memberof Os
   */
  os_variant?: string
  /**
   *
   * @type {string}
   * @memberof Os
   */
  boot_device?: OsBootDeviceEnum
  /**
   *
   * @type {string}
   * @memberof Os
   */
  bios?: OsBiosEnum
  /**
   *
   * @type {string}
   * @memberof Os
   */
  graphic_driver?: OsGraphicDriverEnum
}

export const OsBootDeviceEnum = {
  Hd: 'hd',
  Cdrom: 'cdrom',
} as const

export type OsBootDeviceEnum = (typeof OsBootDeviceEnum)[keyof typeof OsBootDeviceEnum]
export const OsBiosEnum = {
  Legacy: 'LEGACY',
  Uefi: 'UEFI',
  Accord: 'ACCORD',
} as const

export type OsBiosEnum = (typeof OsBiosEnum)[keyof typeof OsBiosEnum]
export const OsGraphicDriverEnum = {
  Virtio: 'virtio',
  Vga: 'vga',
} as const

export type OsGraphicDriverEnum = (typeof OsGraphicDriverEnum)[keyof typeof OsGraphicDriverEnum]

/**
 *
 * @export
 * @interface PageEvent
 */
export interface PageEvent {
  /**
   *
   * @type {Array<Event>}
   * @memberof PageEvent
   */
  items: Array<Event>
  /**
   *
   * @type {number}
   * @memberof PageEvent
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof PageEvent
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof PageEvent
   */
  size: number
}
/**
 *
 * @export
 * @interface PageImage
 */
export interface PageImage {
  /**
   *
   * @type {Array<Image>}
   * @memberof PageImage
   */
  items: Array<Image>
  /**
   *
   * @type {number}
   * @memberof PageImage
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof PageImage
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof PageImage
   */
  size: number
}
/**
 *
 * @export
 * @interface PageInterface
 */
export interface PageInterface {
  /**
   *
   * @type {Array<OpenvairModulesNetworkEntrypointsSchemasInterface>}
   * @memberof PageInterface
   */
  items: Array<OpenvairModulesNetworkEntrypointsSchemasInterface>
  /**
   *
   * @type {number}
   * @memberof PageInterface
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof PageInterface
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof PageInterface
   */
  size: number
}
/**
 *
 * @export
 * @interface PageStorage
 */
export interface PageStorage {
  /**
   *
   * @type {Array<Storage>}
   * @memberof PageStorage
   */
  items: Array<Storage>
  /**
   *
   * @type {number}
   * @memberof PageStorage
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof PageStorage
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof PageStorage
   */
  size: number
}
/**
 *
 * @export
 * @interface PageVirtualMachineInfo
 */
export interface PageVirtualMachineInfo {
  /**
   *
   * @type {Array<VirtualMachineInfo>}
   * @memberof PageVirtualMachineInfo
   */
  items: Array<VirtualMachineInfo>
  /**
   *
   * @type {number}
   * @memberof PageVirtualMachineInfo
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof PageVirtualMachineInfo
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof PageVirtualMachineInfo
   */
  size: number
}
/**
 *
 * @export
 * @interface PageVolume
 */
export interface PageVolume {
  /**
   *
   * @type {Array<Volume>}
   * @memberof PageVolume
   */
  items: Array<Volume>
  /**
   *
   * @type {number}
   * @memberof PageVolume
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof PageVolume
   */
  page: number
  /**
   *
   * @type {number}
   * @memberof PageVolume
   */
  size: number
}
/**
 * Represents a port group configuration.  Attributes:     port_group_name (str): The name of the port group.     is_trunk (str): Indicates if the port group is a trunk (\'yes\' or \'no\').     tags (List[str]): List of VLAN tags associated with the port group.
 * @export
 * @interface PortGroup
 */
export interface PortGroup {
  /**
   *
   * @type {string}
   * @memberof PortGroup
   */
  port_group_name?: string
  /**
   *
   * @type {string}
   * @memberof PortGroup
   */
  is_trunk?: string
  /**
   *
   * @type {Array<string>}
   * @memberof PortGroup
   */
  tags?: Array<string>
}
/**
 *
 * @export
 * @interface QOS
 */
export interface QOS {
  /**
   *
   * @type {string}
   * @memberof QOS
   */
  iops_read?: string
  /**
   *
   * @type {string}
   * @memberof QOS
   */
  iops_write?: string
  /**
   *
   * @type {string}
   * @memberof QOS
   */
  mb_read?: string
  /**
   *
   * @type {string}
   * @memberof QOS
   */
  mb_write?: string
}
/**
 *
 * @export
 * @interface RAM
 */
export interface RAM {
  /**
   *
   * @type {number}
   * @memberof RAM
   */
  size: number
}
/**
 *
 * @export
 * @interface Specs
 */
export interface Specs {
  /**
   *
   * @type {string}
   * @memberof Specs
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof Specs
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof Specs
   */
  mount_version?: string
  /**
   *
   * @type {string}
   * @memberof Specs
   */
  fs_type: SpecsFsTypeEnum
}

export const SpecsFsTypeEnum = {
  Xfs: 'xfs',
  Ext4: 'ext4',
} as const

export type SpecsFsTypeEnum = (typeof SpecsFsTypeEnum)[keyof typeof SpecsFsTypeEnum]

/**
 *
 * @export
 * @interface Storage
 */
export interface Storage {
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  storage_type: string
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  status: string
  /**
   *
   * @type {number}
   * @memberof Storage
   */
  size: number
  /**
   *
   * @type {number}
   * @memberof Storage
   */
  available: number
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  user_id?: string
  /**
   *
   * @type {string}
   * @memberof Storage
   */
  information?: string
  /**
   *
   * @type {StorageExtraSpecs}
   * @memberof Storage
   */
  storage_extra_specs: StorageExtraSpecs
}
/**
 *
 * @export
 * @interface StorageExtraSpecs
 */
export interface StorageExtraSpecs {
  /**
   *
   * @type {string}
   * @memberof StorageExtraSpecs
   */
  ip: string
  /**
   *
   * @type {string}
   * @memberof StorageExtraSpecs
   */
  path: string
  /**
   *
   * @type {string}
   * @memberof StorageExtraSpecs
   */
  mount_version?: string
  /**
   *
   * @type {string}
   * @memberof StorageExtraSpecs
   */
  mount_point?: string
  /**
   *
   * @type {string}
   * @memberof StorageExtraSpecs
   */
  fs_type: StorageExtraSpecsFsTypeEnum
}

export const StorageExtraSpecsFsTypeEnum = {
  Xfs: 'xfs',
  Ext4: 'ext4',
} as const

export type StorageExtraSpecsFsTypeEnum = (typeof StorageExtraSpecsFsTypeEnum)[keyof typeof StorageExtraSpecsFsTypeEnum]

/**
 * Represents storage usage data.  Attributes:     size (int): The total storage size.     used (int): The amount of used storage.     free (int): The amount of free storage.     percentage (float): The percentage of storage usage.     cls (str): The class of the storage.
 * @export
 * @interface StoragesData
 */
export interface StoragesData {
  /**
   *
   * @type {number}
   * @memberof StoragesData
   */
  size: number
  /**
   *
   * @type {number}
   * @memberof StoragesData
   */
  used: number
  /**
   *
   * @type {number}
   * @memberof StoragesData
   */
  free: number
  /**
   *
   * @type {number}
   * @memberof StoragesData
   */
  percentage: number
  /**
   *
   * @type {string}
   * @memberof StoragesData
   */
  cls: string
}
/**
 * Schema for authentication tokens.  Attributes:     access_token (str): The access token for user authentication.     refresh_token (str): The refresh token used to obtain a new access         token.     token_type (str): The type of token, default is \'bearer\'.
 * @export
 * @interface Token
 */
export interface Token {
  /**
   *
   * @type {string}
   * @memberof Token
   */
  access_token: string
  /**
   *
   * @type {string}
   * @memberof Token
   */
  refresh_token: string
  /**
   *
   * @type {string}
   * @memberof Token
   */
  token_type?: string
}
/**
 * Schema for user information including user ID.  Attributes:     id (str): The unique identifier for the user.  Config:     orm_mode (bool): Enable ORM mode for compatibility with ORMs.
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  is_superuser: boolean
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string
}
/**
 * Schema for changing a user\'s password.  Attributes:     new_password (str): The new password for the user.
 * @export
 * @interface UserChangePassword
 */
export interface UserChangePassword {
  /**
   *
   * @type {string}
   * @memberof UserChangePassword
   */
  new_password: string
}
/**
 * Schema for user creation including password.  Attributes:     password (str): The password for the new user.
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  email?: string
  /**
   *
   * @type {boolean}
   * @memberof UserCreate
   */
  is_superuser: boolean
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  password: string
}
/**
 * Schema for user deletion response.  Attributes:     id (str): The unique identifier of the deleted user.     message (str): A message indicating the result of the deletion.
 * @export
 * @interface UserDelete
 */
export interface UserDelete {
  /**
   *
   * @type {string}
   * @memberof UserDelete
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof UserDelete
   */
  message: string
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string
}
/**
 *
 * @export
 * @interface VirtualInterface
 */
export interface VirtualInterface {
  /**
   *
   * @type {string}
   * @memberof VirtualInterface
   */
  mode?: VirtualInterfaceModeEnum
  /**
   *
   * @type {string}
   * @memberof VirtualInterface
   */
  portgroup?: string
  /**
   *
   * @type {string}
   * @memberof VirtualInterface
   */
  interface: string
  /**
   *
   * @type {string}
   * @memberof VirtualInterface
   */
  mac?: string
  /**
   *
   * @type {string}
   * @memberof VirtualInterface
   */
  model?: VirtualInterfaceModelEnum
  /**
   *
   * @type {number}
   * @memberof VirtualInterface
   */
  order?: number
}

export const VirtualInterfaceModeEnum = {
  Bridge: 'bridge',
  Nat: 'nat',
  Default: 'default',
  Isolated: 'isolated',
  Vepa: 'vepa',
  User: 'user',
  VirtualNetwork: 'virtual_network',
} as const

export type VirtualInterfaceModeEnum = (typeof VirtualInterfaceModeEnum)[keyof typeof VirtualInterfaceModeEnum]
export const VirtualInterfaceModelEnum = {
  Virtio: 'virtio',
} as const

export type VirtualInterfaceModelEnum = (typeof VirtualInterfaceModelEnum)[keyof typeof VirtualInterfaceModelEnum]

/**
 *
 * @export
 * @interface VirtualInterfaceInfo
 */
export interface VirtualInterfaceInfo {
  /**
   *
   * @type {string}
   * @memberof VirtualInterfaceInfo
   */
  mode?: VirtualInterfaceInfoModeEnum
  /**
   *
   * @type {string}
   * @memberof VirtualInterfaceInfo
   */
  portgroup?: string
  /**
   *
   * @type {string}
   * @memberof VirtualInterfaceInfo
   */
  interface: string
  /**
   *
   * @type {string}
   * @memberof VirtualInterfaceInfo
   */
  mac?: string
  /**
   *
   * @type {string}
   * @memberof VirtualInterfaceInfo
   */
  model?: VirtualInterfaceInfoModelEnum
  /**
   *
   * @type {number}
   * @memberof VirtualInterfaceInfo
   */
  order?: number
  /**
   *
   * @type {number}
   * @memberof VirtualInterfaceInfo
   */
  id: number
}

export const VirtualInterfaceInfoModeEnum = {
  Bridge: 'bridge',
  Nat: 'nat',
  Default: 'default',
  Isolated: 'isolated',
  Vepa: 'vepa',
  User: 'user',
  VirtualNetwork: 'virtual_network',
} as const

export type VirtualInterfaceInfoModeEnum =
  (typeof VirtualInterfaceInfoModeEnum)[keyof typeof VirtualInterfaceInfoModeEnum]
export const VirtualInterfaceInfoModelEnum = {
  Virtio: 'virtio',
} as const

export type VirtualInterfaceInfoModelEnum =
  (typeof VirtualInterfaceInfoModelEnum)[keyof typeof VirtualInterfaceInfoModelEnum]

/**
 *
 * @export
 * @interface VirtualMachineInfo
 */
export interface VirtualMachineInfo {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineInfo
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof VirtualMachineInfo
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof VirtualMachineInfo
   */
  power_state: string
  /**
   *
   * @type {string}
   * @memberof VirtualMachineInfo
   */
  status: string
  /**
   *
   * @type {string}
   * @memberof VirtualMachineInfo
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof VirtualMachineInfo
   */
  information?: string
  /**
   *
   * @type {Cpu}
   * @memberof VirtualMachineInfo
   */
  cpu: Cpu
  /**
   *
   * @type {RAM}
   * @memberof VirtualMachineInfo
   */
  ram: RAM
  /**
   *
   * @type {Os}
   * @memberof VirtualMachineInfo
   */
  os: Os
  /**
   *
   * @type {GraphicInterfaceInfo}
   * @memberof VirtualMachineInfo
   */
  graphic_interface: GraphicInterfaceInfo
  /**
   *
   * @type {Array<OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo>}
   * @memberof VirtualMachineInfo
   */
  disks: Array<OpenvairModulesVirtualMachinesEntrypointsSchemasDiskInfo>
  /**
   *
   * @type {Array<VirtualInterfaceInfo>}
   * @memberof VirtualMachineInfo
   */
  virtual_interfaces: Array<VirtualInterfaceInfo>
}
/**
 * Represents a virtual network configuration.  Attributes:     network_name (str): The name of the virtual network.     forward_mode (str): The forwarding mode of the virtual network.     bridge (str): The bridge associated with the virtual network.     virtual_port_type (str): The type of virtual port used by the virtual         network.     port_groups (List[PortGroup]): List of port groups associated with the         virtual network.
 * @export
 * @interface VirtualNetwork
 */
export interface VirtualNetwork {
  /**
   *
   * @type {string}
   * @memberof VirtualNetwork
   */
  network_name?: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetwork
   */
  forward_mode?: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetwork
   */
  bridge?: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetwork
   */
  virtual_port_type?: string
  /**
   *
   * @type {Array<PortGroup>}
   * @memberof VirtualNetwork
   */
  port_groups: Array<PortGroup>
}
/**
 * Represents a response containing information about a virtual network.  Attributes:     id (UUID4): The ID of the virtual network.     state (str): The state of the virtual network.     autostart (str): Indicates if the virtual network should start         automatically.     persistent (str): Indicates if the virtual network configuration is         persistent.     virsh_xml (str): The virsh XML configuration of the virtual network.
 * @export
 * @interface VirtualNetworkResponse
 */
export interface VirtualNetworkResponse {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  network_name?: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  forward_mode?: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  bridge?: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  virtual_port_type?: string
  /**
   *
   * @type {Array<PortGroup>}
   * @memberof VirtualNetworkResponse
   */
  port_groups: Array<PortGroup>
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  state: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  autostart: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  persistent: string
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkResponse
   */
  virsh_xml: string
}
/**
 *
 * @export
 * @interface Vnc
 */
export interface Vnc {
  /**
   *
   * @type {string}
   * @memberof Vnc
   */
  url?: string
}
/**
 *
 * @export
 * @interface Volume
 */
export interface Volume {
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  storage_id?: string
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  user_id?: string
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  format: string
  /**
   *
   * @type {number}
   * @memberof Volume
   */
  size: number
  /**
   *
   * @type {number}
   * @memberof Volume
   */
  used?: number
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof Volume
   */
  information?: string
  /**
   *
   * @type {Array<OpenvairModulesVolumeEntrypointsSchemasAttachment>}
   * @memberof Volume
   */
  attachments: Array<OpenvairModulesVolumeEntrypointsSchemasAttachment>
  /**
   *
   * @type {boolean}
   * @memberof Volume
   */
  read_only?: boolean
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Authenticate a user and return access and refresh tokens.  Args:     form_data: The form data containing username and password.     crud: UserCrud instance for performing CRUD operations.  Returns:     dict: A dictionary containing access and refresh tokens and         the token type.
     * @summary Auth
     * @param {string} username
     * @param {string} password
     * @param {string} [grantType]
     * @param {string} [scope]
     * @param {string} [clientId]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authAuthPost: async (
      username: string,
      password: string,
      grantType?: string,
      scope?: string,
      clientId?: string,
      clientSecret?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists('authAuthPost', 'username', username)
      // verify required parameter 'password' is not null or undefined
      assertParamExists('authAuthPost', 'password', password)
      const localVarPath = `/auth/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new URLSearchParams()

      if (grantType !== undefined) {
        localVarFormParams.set('grant_type', grantType as any)
      }

      if (username !== undefined) {
        localVarFormParams.set('username', username as any)
      }

      if (password !== undefined) {
        localVarFormParams.set('password', password as any)
      }

      if (scope !== undefined) {
        localVarFormParams.set('scope', scope as any)
      }

      if (clientId !== undefined) {
        localVarFormParams.set('client_id', clientId as any)
      }

      if (clientSecret !== undefined) {
        localVarFormParams.set('client_secret', clientSecret as any)
      }

      localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams.toString()

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Refresh an access token using a refresh token.  Args:     refresh_token: The refresh token provided by the user.  Returns:     dict: A dictionary containing the new access token, refresh token,         and token type.  Raises:     HTTPException: If the refresh token is expired or invalid.
     * @summary Refresh Token
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshTokenAuthRefreshPost: async (
      refreshToken: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists('refreshTokenAuthRefreshPost', 'refreshToken', refreshToken)
      const localVarPath = `/auth/refresh`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (refreshToken !== undefined) {
        localVarQueryParameter['refresh_token'] = refreshToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Authenticate a user and return access and refresh tokens.  Args:     form_data: The form data containing username and password.     crud: UserCrud instance for performing CRUD operations.  Returns:     dict: A dictionary containing access and refresh tokens and         the token type.
     * @summary Auth
     * @param {string} username
     * @param {string} password
     * @param {string} [grantType]
     * @param {string} [scope]
     * @param {string} [clientId]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authAuthPost(
      username: string,
      password: string,
      grantType?: string,
      scope?: string,
      clientId?: string,
      clientSecret?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authAuthPost(
        username,
        password,
        grantType,
        scope,
        clientId,
        clientSecret,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['AuthApi.authAuthPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Refresh an access token using a refresh token.  Args:     refresh_token: The refresh token provided by the user.  Returns:     dict: A dictionary containing the new access token, refresh token,         and token type.  Raises:     HTTPException: If the refresh token is expired or invalid.
     * @summary Refresh Token
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshTokenAuthRefreshPost(
      refreshToken: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTokenAuthRefreshPost(refreshToken, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['AuthApi.refreshTokenAuthRefreshPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * Authenticate a user and return access and refresh tokens.  Args:     form_data: The form data containing username and password.     crud: UserCrud instance for performing CRUD operations.  Returns:     dict: A dictionary containing access and refresh tokens and         the token type.
     * @summary Auth
     * @param {AuthApiAuthAuthPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authAuthPost(requestParameters: AuthApiAuthAuthPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
      return localVarFp
        .authAuthPost(
          requestParameters.username,
          requestParameters.password,
          requestParameters.grantType,
          requestParameters.scope,
          requestParameters.clientId,
          requestParameters.clientSecret,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Refresh an access token using a refresh token.  Args:     refresh_token: The refresh token provided by the user.  Returns:     dict: A dictionary containing the new access token, refresh token,         and token type.  Raises:     HTTPException: If the refresh token is expired or invalid.
     * @summary Refresh Token
     * @param {AuthApiRefreshTokenAuthRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshTokenAuthRefreshPost(
      requestParameters: AuthApiRefreshTokenAuthRefreshPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Token> {
      return localVarFp
        .refreshTokenAuthRefreshPost(requestParameters.refreshToken, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for authAuthPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthAuthPostRequest
 */
export interface AuthApiAuthAuthPostRequest {
  /**
   *
   * @type {string}
   * @memberof AuthApiAuthAuthPost
   */
  readonly username: string

  /**
   *
   * @type {string}
   * @memberof AuthApiAuthAuthPost
   */
  readonly password: string

  /**
   *
   * @type {string}
   * @memberof AuthApiAuthAuthPost
   */
  readonly grantType?: string

  /**
   *
   * @type {string}
   * @memberof AuthApiAuthAuthPost
   */
  readonly scope?: string

  /**
   *
   * @type {string}
   * @memberof AuthApiAuthAuthPost
   */
  readonly clientId?: string

  /**
   *
   * @type {string}
   * @memberof AuthApiAuthAuthPost
   */
  readonly clientSecret?: string
}

/**
 * Request parameters for refreshTokenAuthRefreshPost operation in AuthApi.
 * @export
 * @interface AuthApiRefreshTokenAuthRefreshPostRequest
 */
export interface AuthApiRefreshTokenAuthRefreshPostRequest {
  /**
   *
   * @type {string}
   * @memberof AuthApiRefreshTokenAuthRefreshPost
   */
  readonly refreshToken: string
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Authenticate a user and return access and refresh tokens.  Args:     form_data: The form data containing username and password.     crud: UserCrud instance for performing CRUD operations.  Returns:     dict: A dictionary containing access and refresh tokens and         the token type.
   * @summary Auth
   * @param {AuthApiAuthAuthPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authAuthPost(requestParameters: AuthApiAuthAuthPostRequest, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authAuthPost(
        requestParameters.username,
        requestParameters.password,
        requestParameters.grantType,
        requestParameters.scope,
        requestParameters.clientId,
        requestParameters.clientSecret,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Refresh an access token using a refresh token.  Args:     refresh_token: The refresh token provided by the user.  Returns:     dict: A dictionary containing the new access token, refresh token,         and token type.  Raises:     HTTPException: If the refresh token is expired or invalid.
   * @summary Refresh Token
   * @param {AuthApiRefreshTokenAuthRefreshPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refreshTokenAuthRefreshPost(
    requestParameters: AuthApiRefreshTokenAuthRefreshPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .refreshTokenAuthRefreshPost(requestParameters.refreshToken, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * BlockDevicesApi - axios parameter creator
 * @export
 */
export const BlockDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Gets the IQN associated with the current host.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data.         Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.IQN: A `schemas.IQN` object containing the IQN associated with         the current host.  Raises:     HTTPException: If there is an error while retrieving the host IQN, this         function raises an `HTTPException` with an appropriate status code         and error message.
     * @summary Get Host Iqn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHostIqnBlockDevicesGetIqnGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/block-devices/get-iqn`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve sessions associated with block devices.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the database.         Defaults to `Depends(InterfaceCrud)`.  Returns:     List[schemas.Session]: A list of schemas.Session representing the         sessions. Each object contains information about a session  Raises:     HTTPException: If there is an error while retrieving the sessions, it         raises an HTTPException with an appropriate status code and error         message.
     * @summary Get Sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionsBlockDevicesSessionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/block-devices/sessions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Perform LIP scan on Fibre Channel host adapters.  LIP - Loop Initialization Protocol  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary functionality for         performing the LIP scan.         Defaults to `Depends(InterfaceCrud)`.  Returns:     str: A message about the result of the LIP scan.  Raises:     OSError: If there is an error accessing or writing to the \'issue_lip\'         file while performing the LIP scan.
     * @summary Lip Scan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lipScanBlockDevicesLipScanGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/block-devices/lip_scan`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Log in to the specified iSCSI target.  Args:     data (schemas.Interface): The data required for the login operation,         such as target details, authentication credentials, etc.     user_data (Dict, optional): Additional user data to be included in the         request.         Defaults to `Depends(get_current_user)`.     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data for the login         operation. Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.InterfaceLogin: A `schemas.InterfaceLogin` object containing the         result of the login operation.  Raises:     HTTPException: If there is an error while logging in to the iSCSI         target, this function raises an `HTTPException` with an appropriate         status code and error message.
     * @summary Login
     * @param {OpenvairModulesBlockDeviceEntrypointsSchemasInterface} openvairModulesBlockDeviceEntrypointsSchemasInterface
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginBlockDevicesLoginPost: async (
      openvairModulesBlockDeviceEntrypointsSchemasInterface: OpenvairModulesBlockDeviceEntrypointsSchemasInterface,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'openvairModulesBlockDeviceEntrypointsSchemasInterface' is not null or undefined
      assertParamExists(
        'loginBlockDevicesLoginPost',
        'openvairModulesBlockDeviceEntrypointsSchemasInterface',
        openvairModulesBlockDeviceEntrypointsSchemasInterface
      )
      const localVarPath = `/block-devices/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        openvairModulesBlockDeviceEntrypointsSchemasInterface,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Log out from the specified iSCSI target.  Args:     data (schemas.InterfaceDeleted): The data required for the logout         operation.     user_data (Dict, optional): Additional user data to be included in the         request. Defaults to Depends(get_current_user).     crud (InterfaceCrud, optional): The InterfaceCrud instance to use for         the logout operation. Defaults to Depends(InterfaceCrud).  Returns:     schemas.InterfaceDeleted: The result of the logout operation.
     * @summary Logout
     * @param {InterfaceDeleted} interfaceDeleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutBlockDevicesLogoutPost: async (
      interfaceDeleted: InterfaceDeleted,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'interfaceDeleted' is not null or undefined
      assertParamExists('logoutBlockDevicesLogoutPost', 'interfaceDeleted', interfaceDeleted)
      const localVarPath = `/block-devices/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(interfaceDeleted, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BlockDevicesApi - functional programming interface
 * @export
 */
export const BlockDevicesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BlockDevicesApiAxiosParamCreator(configuration)
  return {
    /**
     * Gets the IQN associated with the current host.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data.         Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.IQN: A `schemas.IQN` object containing the IQN associated with         the current host.  Raises:     HTTPException: If there is an error while retrieving the host IQN, this         function raises an `HTTPException` with an appropriate status code         and error message.
     * @summary Get Host Iqn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHostIqnBlockDevicesGetIqnGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IQN>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getHostIqnBlockDevicesGetIqnGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BlockDevicesApi.getHostIqnBlockDevicesGetIqnGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieve sessions associated with block devices.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the database.         Defaults to `Depends(InterfaceCrud)`.  Returns:     List[schemas.Session]: A list of schemas.Session representing the         sessions. Each object contains information about a session  Raises:     HTTPException: If there is an error while retrieving the sessions, it         raises an HTTPException with an appropriate status code and error         message.
     * @summary Get Sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionsBlockDevicesSessionsGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsBlockDevicesSessionsGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BlockDevicesApi.getSessionsBlockDevicesSessionsGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Perform LIP scan on Fibre Channel host adapters.  LIP - Loop Initialization Protocol  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary functionality for         performing the LIP scan.         Defaults to `Depends(InterfaceCrud)`.  Returns:     str: A message about the result of the LIP scan.  Raises:     OSError: If there is an error accessing or writing to the \'issue_lip\'         file while performing the LIP scan.
     * @summary Lip Scan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lipScanBlockDevicesLipScanGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lipScanBlockDevicesLipScanGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BlockDevicesApi.lipScanBlockDevicesLipScanGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Log in to the specified iSCSI target.  Args:     data (schemas.Interface): The data required for the login operation,         such as target details, authentication credentials, etc.     user_data (Dict, optional): Additional user data to be included in the         request.         Defaults to `Depends(get_current_user)`.     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data for the login         operation. Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.InterfaceLogin: A `schemas.InterfaceLogin` object containing the         result of the login operation.  Raises:     HTTPException: If there is an error while logging in to the iSCSI         target, this function raises an `HTTPException` with an appropriate         status code and error message.
     * @summary Login
     * @param {OpenvairModulesBlockDeviceEntrypointsSchemasInterface} openvairModulesBlockDeviceEntrypointsSchemasInterface
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginBlockDevicesLoginPost(
      openvairModulesBlockDeviceEntrypointsSchemasInterface: OpenvairModulesBlockDeviceEntrypointsSchemasInterface,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceLogin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginBlockDevicesLoginPost(
        openvairModulesBlockDeviceEntrypointsSchemasInterface,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BlockDevicesApi.loginBlockDevicesLoginPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Log out from the specified iSCSI target.  Args:     data (schemas.InterfaceDeleted): The data required for the logout         operation.     user_data (Dict, optional): Additional user data to be included in the         request. Defaults to Depends(get_current_user).     crud (InterfaceCrud, optional): The InterfaceCrud instance to use for         the logout operation. Defaults to Depends(InterfaceCrud).  Returns:     schemas.InterfaceDeleted: The result of the logout operation.
     * @summary Logout
     * @param {InterfaceDeleted} interfaceDeleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutBlockDevicesLogoutPost(
      interfaceDeleted: InterfaceDeleted,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceDeleted>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutBlockDevicesLogoutPost(interfaceDeleted, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['BlockDevicesApi.logoutBlockDevicesLogoutPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * BlockDevicesApi - factory interface
 * @export
 */
export const BlockDevicesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BlockDevicesApiFp(configuration)
  return {
    /**
     * Gets the IQN associated with the current host.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data.         Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.IQN: A `schemas.IQN` object containing the IQN associated with         the current host.  Raises:     HTTPException: If there is an error while retrieving the host IQN, this         function raises an `HTTPException` with an appropriate status code         and error message.
     * @summary Get Host Iqn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHostIqnBlockDevicesGetIqnGet(options?: RawAxiosRequestConfig): AxiosPromise<IQN> {
      return localVarFp.getHostIqnBlockDevicesGetIqnGet(options).then(request => request(axios, basePath))
    },
    /**
     * Retrieve sessions associated with block devices.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the database.         Defaults to `Depends(InterfaceCrud)`.  Returns:     List[schemas.Session]: A list of schemas.Session representing the         sessions. Each object contains information about a session  Raises:     HTTPException: If there is an error while retrieving the sessions, it         raises an HTTPException with an appropriate status code and error         message.
     * @summary Get Sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionsBlockDevicesSessionsGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
      return localVarFp.getSessionsBlockDevicesSessionsGet(options).then(request => request(axios, basePath))
    },
    /**
     * Perform LIP scan on Fibre Channel host adapters.  LIP - Loop Initialization Protocol  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary functionality for         performing the LIP scan.         Defaults to `Depends(InterfaceCrud)`.  Returns:     str: A message about the result of the LIP scan.  Raises:     OSError: If there is an error accessing or writing to the \'issue_lip\'         file while performing the LIP scan.
     * @summary Lip Scan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lipScanBlockDevicesLipScanGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
      return localVarFp.lipScanBlockDevicesLipScanGet(options).then(request => request(axios, basePath))
    },
    /**
     * Log in to the specified iSCSI target.  Args:     data (schemas.Interface): The data required for the login operation,         such as target details, authentication credentials, etc.     user_data (Dict, optional): Additional user data to be included in the         request.         Defaults to `Depends(get_current_user)`.     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data for the login         operation. Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.InterfaceLogin: A `schemas.InterfaceLogin` object containing the         result of the login operation.  Raises:     HTTPException: If there is an error while logging in to the iSCSI         target, this function raises an `HTTPException` with an appropriate         status code and error message.
     * @summary Login
     * @param {BlockDevicesApiLoginBlockDevicesLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginBlockDevicesLoginPost(
      requestParameters: BlockDevicesApiLoginBlockDevicesLoginPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<InterfaceLogin> {
      return localVarFp
        .loginBlockDevicesLoginPost(requestParameters.openvairModulesBlockDeviceEntrypointsSchemasInterface, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Log out from the specified iSCSI target.  Args:     data (schemas.InterfaceDeleted): The data required for the logout         operation.     user_data (Dict, optional): Additional user data to be included in the         request. Defaults to Depends(get_current_user).     crud (InterfaceCrud, optional): The InterfaceCrud instance to use for         the logout operation. Defaults to Depends(InterfaceCrud).  Returns:     schemas.InterfaceDeleted: The result of the logout operation.
     * @summary Logout
     * @param {BlockDevicesApiLogoutBlockDevicesLogoutPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutBlockDevicesLogoutPost(
      requestParameters: BlockDevicesApiLogoutBlockDevicesLogoutPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<InterfaceDeleted> {
      return localVarFp
        .logoutBlockDevicesLogoutPost(requestParameters.interfaceDeleted, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for loginBlockDevicesLoginPost operation in BlockDevicesApi.
 * @export
 * @interface BlockDevicesApiLoginBlockDevicesLoginPostRequest
 */
export interface BlockDevicesApiLoginBlockDevicesLoginPostRequest {
  /**
   *
   * @type {OpenvairModulesBlockDeviceEntrypointsSchemasInterface}
   * @memberof BlockDevicesApiLoginBlockDevicesLoginPost
   */
  readonly openvairModulesBlockDeviceEntrypointsSchemasInterface: OpenvairModulesBlockDeviceEntrypointsSchemasInterface
}

/**
 * Request parameters for logoutBlockDevicesLogoutPost operation in BlockDevicesApi.
 * @export
 * @interface BlockDevicesApiLogoutBlockDevicesLogoutPostRequest
 */
export interface BlockDevicesApiLogoutBlockDevicesLogoutPostRequest {
  /**
   *
   * @type {InterfaceDeleted}
   * @memberof BlockDevicesApiLogoutBlockDevicesLogoutPost
   */
  readonly interfaceDeleted: InterfaceDeleted
}

/**
 * BlockDevicesApi - object-oriented interface
 * @export
 * @class BlockDevicesApi
 * @extends {BaseAPI}
 */
export class BlockDevicesApi extends BaseAPI {
  /**
   * Gets the IQN associated with the current host.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data.         Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.IQN: A `schemas.IQN` object containing the IQN associated with         the current host.  Raises:     HTTPException: If there is an error while retrieving the host IQN, this         function raises an `HTTPException` with an appropriate status code         and error message.
   * @summary Get Host Iqn
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockDevicesApi
   */
  public getHostIqnBlockDevicesGetIqnGet(options?: RawAxiosRequestConfig) {
    return BlockDevicesApiFp(this.configuration)
      .getHostIqnBlockDevicesGetIqnGet(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieve sessions associated with block devices.  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the database.         Defaults to `Depends(InterfaceCrud)`.  Returns:     List[schemas.Session]: A list of schemas.Session representing the         sessions. Each object contains information about a session  Raises:     HTTPException: If there is an error while retrieving the sessions, it         raises an HTTPException with an appropriate status code and error         message.
   * @summary Get Sessions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockDevicesApi
   */
  public getSessionsBlockDevicesSessionsGet(options?: RawAxiosRequestConfig) {
    return BlockDevicesApiFp(this.configuration)
      .getSessionsBlockDevicesSessionsGet(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Perform LIP scan on Fibre Channel host adapters.  LIP - Loop Initialization Protocol  Args:     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary functionality for         performing the LIP scan.         Defaults to `Depends(InterfaceCrud)`.  Returns:     str: A message about the result of the LIP scan.  Raises:     OSError: If there is an error accessing or writing to the \'issue_lip\'         file while performing the LIP scan.
   * @summary Lip Scan
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockDevicesApi
   */
  public lipScanBlockDevicesLipScanGet(options?: RawAxiosRequestConfig) {
    return BlockDevicesApiFp(this.configuration)
      .lipScanBlockDevicesLipScanGet(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Log in to the specified iSCSI target.  Args:     data (schemas.Interface): The data required for the login operation,         such as target details, authentication credentials, etc.     user_data (Dict, optional): Additional user data to be included in the         request.         Defaults to `Depends(get_current_user)`.     crud (InterfaceCrud, optional): An instance of the `InterfaceCrud`         interface that provides access to the necessary data for the login         operation. Defaults to `Depends(InterfaceCrud)`.  Returns:     schemas.InterfaceLogin: A `schemas.InterfaceLogin` object containing the         result of the login operation.  Raises:     HTTPException: If there is an error while logging in to the iSCSI         target, this function raises an `HTTPException` with an appropriate         status code and error message.
   * @summary Login
   * @param {BlockDevicesApiLoginBlockDevicesLoginPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockDevicesApi
   */
  public loginBlockDevicesLoginPost(
    requestParameters: BlockDevicesApiLoginBlockDevicesLoginPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BlockDevicesApiFp(this.configuration)
      .loginBlockDevicesLoginPost(requestParameters.openvairModulesBlockDeviceEntrypointsSchemasInterface, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Log out from the specified iSCSI target.  Args:     data (schemas.InterfaceDeleted): The data required for the logout         operation.     user_data (Dict, optional): Additional user data to be included in the         request. Defaults to Depends(get_current_user).     crud (InterfaceCrud, optional): The InterfaceCrud instance to use for         the logout operation. Defaults to Depends(InterfaceCrud).  Returns:     schemas.InterfaceDeleted: The result of the logout operation.
   * @summary Logout
   * @param {BlockDevicesApiLogoutBlockDevicesLogoutPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlockDevicesApi
   */
  public logoutBlockDevicesLogoutPost(
    requestParameters: BlockDevicesApiLogoutBlockDevicesLogoutPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BlockDevicesApiFp(this.configuration)
      .logoutBlockDevicesLogoutPost(requestParameters.interfaceDeleted, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve node resource data.  This function takes a `DashboardCrud` object as a dependency and returns a `NodeInfo` object containing the node resource data. The `DashboardCrud` object is responsible for fetching the data from the `PrometheusRepository` class.  Args:     crud (DashboardCrud): The `DashboardCrud` object used to fetch the node         resource data.  Returns:     NodeInfo: A pydantic model containing the node resource data.
     * @summary Get Node Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeDataDashboardGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/dashboard/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieve node resource data.  This function takes a `DashboardCrud` object as a dependency and returns a `NodeInfo` object containing the node resource data. The `DashboardCrud` object is responsible for fetching the data from the `PrometheusRepository` class.  Args:     crud (DashboardCrud): The `DashboardCrud` object used to fetch the node         resource data.  Returns:     NodeInfo: A pydantic model containing the node resource data.
     * @summary Get Node Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNodeDataDashboardGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeDataDashboardGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['DashboardApi.getNodeDataDashboardGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DashboardApiFp(configuration)
  return {
    /**
     * Retrieve node resource data.  This function takes a `DashboardCrud` object as a dependency and returns a `NodeInfo` object containing the node resource data. The `DashboardCrud` object is responsible for fetching the data from the `PrometheusRepository` class.  Args:     crud (DashboardCrud): The `DashboardCrud` object used to fetch the node         resource data.  Returns:     NodeInfo: A pydantic model containing the node resource data.
     * @summary Get Node Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNodeDataDashboardGet(options?: RawAxiosRequestConfig): AxiosPromise<NodeInfo> {
      return localVarFp.getNodeDataDashboardGet(options).then(request => request(axios, basePath))
    },
  }
}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
  /**
   * Retrieve node resource data.  This function takes a `DashboardCrud` object as a dependency and returns a `NodeInfo` object containing the node resource data. The `DashboardCrud` object is responsible for fetching the data from the `PrometheusRepository` class.  Args:     crud (DashboardCrud): The `DashboardCrud` object used to fetch the node         resource data.  Returns:     NodeInfo: A pydantic model containing the node resource data.
   * @summary Get Node Data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DashboardApi
   */
  public getNodeDataDashboardGet(options?: RawAxiosRequestConfig) {
    return DashboardApiFp(this.configuration)
      .getNodeDataDashboardGet(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rootGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['DefaultApi.rootGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     *
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
      return localVarFp.rootGet(options).then(request => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary Root
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public rootGet(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .rootGet(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Download all events as a CSV file.  This endpoint retrieves all events using the EventCrud class, generates a CSV file containing the event data, and returns it as a streaming response.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     StreamingResponse: A streaming response with the CSV file content.
     * @summary Download Events
     * @param {string} [moduleName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadEventsEventDownloadGet: async (
      moduleName?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/event/download`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (moduleName !== undefined) {
        localVarQueryParameter['module_name'] = moduleName
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve all events from the database.  This endpoint retrieves all events using the EventCrud class and returns them in a paginated format.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     Page[schemas.Event]: A paginated list of events.  Raises:     HTTPException: If any database error occurs or events are not found.
     * @summary Get Events
     * @param {string} [moduleName]
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsEventGet: async (
      moduleName?: string,
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/event/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (moduleName !== undefined) {
        localVarQueryParameter['module_name'] = moduleName
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
  return {
    /**
     * Download all events as a CSV file.  This endpoint retrieves all events using the EventCrud class, generates a CSV file containing the event data, and returns it as a streaming response.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     StreamingResponse: A streaming response with the CSV file content.
     * @summary Download Events
     * @param {string} [moduleName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadEventsEventDownloadGet(
      moduleName?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadEventsEventDownloadGet(moduleName, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['EventApi.downloadEventsEventDownloadGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieve all events from the database.  This endpoint retrieves all events using the EventCrud class and returns them in a paginated format.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     Page[schemas.Event]: A paginated list of events.  Raises:     HTTPException: If any database error occurs or events are not found.
     * @summary Get Events
     * @param {string} [moduleName]
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEventsEventGet(
      moduleName?: string,
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageEvent>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsEventGet(moduleName, page, size, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['EventApi.getEventsEventGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EventApiFp(configuration)
  return {
    /**
     * Download all events as a CSV file.  This endpoint retrieves all events using the EventCrud class, generates a CSV file containing the event data, and returns it as a streaming response.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     StreamingResponse: A streaming response with the CSV file content.
     * @summary Download Events
     * @param {EventApiDownloadEventsEventDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadEventsEventDownloadGet(
      requestParameters: EventApiDownloadEventsEventDownloadGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<DownloadResponse> {
      return localVarFp
        .downloadEventsEventDownloadGet(requestParameters.moduleName, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieve all events from the database.  This endpoint retrieves all events using the EventCrud class and returns them in a paginated format.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     Page[schemas.Event]: A paginated list of events.  Raises:     HTTPException: If any database error occurs or events are not found.
     * @summary Get Events
     * @param {EventApiGetEventsEventGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventsEventGet(
      requestParameters: EventApiGetEventsEventGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageEvent> {
      return localVarFp
        .getEventsEventGet(requestParameters.moduleName, requestParameters.page, requestParameters.size, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for downloadEventsEventDownloadGet operation in EventApi.
 * @export
 * @interface EventApiDownloadEventsEventDownloadGetRequest
 */
export interface EventApiDownloadEventsEventDownloadGetRequest {
  /**
   *
   * @type {string}
   * @memberof EventApiDownloadEventsEventDownloadGet
   */
  readonly moduleName?: string
}

/**
 * Request parameters for getEventsEventGet operation in EventApi.
 * @export
 * @interface EventApiGetEventsEventGetRequest
 */
export interface EventApiGetEventsEventGetRequest {
  /**
   *
   * @type {string}
   * @memberof EventApiGetEventsEventGet
   */
  readonly moduleName?: string

  /**
   *
   * @type {number}
   * @memberof EventApiGetEventsEventGet
   */
  readonly page?: number

  /**
   *
   * @type {number}
   * @memberof EventApiGetEventsEventGet
   */
  readonly size?: number
}

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
  /**
   * Download all events as a CSV file.  This endpoint retrieves all events using the EventCrud class, generates a CSV file containing the event data, and returns it as a streaming response.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     StreamingResponse: A streaming response with the CSV file content.
   * @summary Download Events
   * @param {EventApiDownloadEventsEventDownloadGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventApi
   */
  public downloadEventsEventDownloadGet(
    requestParameters: EventApiDownloadEventsEventDownloadGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return EventApiFp(this.configuration)
      .downloadEventsEventDownloadGet(requestParameters.moduleName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieve all events from the database.  This endpoint retrieves all events using the EventCrud class and returns them in a paginated format.  Args:     crud (EventCrud): Instance of EventCrud for database operations.  Returns:     Page[schemas.Event]: A paginated list of events.  Raises:     HTTPException: If any database error occurs or events are not found.
   * @summary Get Events
   * @param {EventApiGetEventsEventGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventApi
   */
  public getEventsEventGet(requestParameters: EventApiGetEventsEventGetRequest = {}, options?: RawAxiosRequestConfig) {
    return EventApiFp(this.configuration)
      .getEventsEventGet(requestParameters.moduleName, requestParameters.page, requestParameters.size, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Attach an image to a VM  The first line of the function is a docstring. This is a string that describes what the function does. It\'s a good idea to include a docstring for every function you write  Args:     image_id (str): str - the id of the image to be attached     data (str): str - the id of the VM to which the image will be attached     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     schemas.AttachImageInfo: The attached image.
     * @summary Attach Image
     * @param {string} imageId Image id (UUID4)
     * @param {OpenvairModulesImageEntrypointsSchemasAttachImage} openvairModulesImageEntrypointsSchemasAttachImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachImageImagesImageIdAttachPost: async (
      imageId: string,
      openvairModulesImageEntrypointsSchemasAttachImage: OpenvairModulesImageEntrypointsSchemasAttachImage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imageId' is not null or undefined
      assertParamExists('attachImageImagesImageIdAttachPost', 'imageId', imageId)
      // verify required parameter 'openvairModulesImageEntrypointsSchemasAttachImage' is not null or undefined
      assertParamExists(
        'attachImageImagesImageIdAttachPost',
        'openvairModulesImageEntrypointsSchemasAttachImage',
        openvairModulesImageEntrypointsSchemasAttachImage
      )
      const localVarPath = `/images/{image_id}/attach/`.replace(`{${'image_id'}}`, encodeURIComponent(String(imageId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        openvairModulesImageEntrypointsSchemasAttachImage,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It deletes an image from the database  Args:     image_id (str): str - the image id to delete     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     JSONResponse(status_code=status.HTTP_200_OK, content=message)
     * @summary Delete Image
     * @param {string} imageId Image id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImageImagesImageIdDelete: async (
      imageId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imageId' is not null or undefined
      assertParamExists('deleteImageImagesImageIdDelete', 'imageId', imageId)
      const localVarPath = `/images/{image_id}/`.replace(`{${'image_id'}}`, encodeURIComponent(String(imageId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes an image_id and a vm_id, and returns a detached_image  Args:     image_id (str): str - the id of the image to be detached     detach_info (str): str - the id of the VM to which the image is attached     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The detached image.
     * @summary Detach Image
     * @param {string} imageId Image id (UUID4)
     * @param {DetachImage} detachImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachImageImagesImageIdDetachDelete: async (
      imageId: string,
      detachImage: DetachImage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'imageId' is not null or undefined
      assertParamExists('detachImageImagesImageIdDetachDelete', 'imageId', imageId)
      // verify required parameter 'detachImage' is not null or undefined
      assertParamExists('detachImageImagesImageIdDetachDelete', 'detachImage', detachImage)
      const localVarPath = `/images/{image_id}/detach/`.replace(`{${'image_id'}}`, encodeURIComponent(String(imageId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(detachImage, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns the image with the specified id  It takes an image id, uses the ImageCrud dependency to get the image, and returns the image  Args:     image_id (str): str = Query(None, description=\"Image id\")     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the ImageCrud class will be instantiated and passed to     the function as a parameter.  Returns:     schemas.Image: The image is being returned.
     * @summary Get Image
     * @param {string} imageId Image id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImageImagesImageIdGet: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'imageId' is not null or undefined
      assertParamExists('getImageImagesImageIdGet', 'imageId', imageId)
      const localVarPath = `/images/{image_id}/`.replace(`{${'image_id'}}`, encodeURIComponent(String(imageId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It gets all the images from the database and returns them  Args:     storage_id: Storage id     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the function will receive an instance of ImageCrud class.  Returns:     Page[schemas.Image]: A list of images.
     * @summary Get Images
     * @param {string} [storageId] Storage id (UUID4)
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesImagesGet: async (
      storageId?: string,
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/images/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (storageId !== undefined) {
        localVarQueryParameter['storage_id'] = storageId
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Uploads an image to the storage.  It reads the image from the request, saves it to a temporary file, and then passes the file name to the `ImageCrud` class  Args:     storage_id (str): str - the id of the storage where the image will be     uploaded     name (str): str - the name of the image.     description (str): str - the description of the image.     image (UploadFile): UploadFile = File(...)     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The image object.
     * @summary Upload Image
     * @param {File} image Upload image.
     * @param {string} [description] Image description
     * @param {string} [storageId] Storage id (UUID4)
     * @param {string} [name] Image name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImageImagesUploadPost: async (
      image: File,
      description?: string,
      storageId?: string,
      name?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'image' is not null or undefined
      assertParamExists('uploadImageImagesUploadPost', 'image', image)
      const localVarPath = `/images/upload/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (description !== undefined) {
        localVarQueryParameter['description'] = description
      }

      if (storageId !== undefined) {
        localVarQueryParameter['storage_id'] = storageId
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (image !== undefined) {
        localVarFormParams.append('image', image as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
  return {
    /**
     * Attach an image to a VM  The first line of the function is a docstring. This is a string that describes what the function does. It\'s a good idea to include a docstring for every function you write  Args:     image_id (str): str - the id of the image to be attached     data (str): str - the id of the VM to which the image will be attached     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     schemas.AttachImageInfo: The attached image.
     * @summary Attach Image
     * @param {string} imageId Image id (UUID4)
     * @param {OpenvairModulesImageEntrypointsSchemasAttachImage} openvairModulesImageEntrypointsSchemasAttachImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attachImageImagesImageIdAttachPost(
      imageId: string,
      openvairModulesImageEntrypointsSchemasAttachImage: OpenvairModulesImageEntrypointsSchemasAttachImage,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachImageInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.attachImageImagesImageIdAttachPost(
        imageId,
        openvairModulesImageEntrypointsSchemasAttachImage,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ImageApi.attachImageImagesImageIdAttachPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It deletes an image from the database  Args:     image_id (str): str - the image id to delete     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     JSONResponse(status_code=status.HTTP_200_OK, content=message)
     * @summary Delete Image
     * @param {string} imageId Image id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteImageImagesImageIdDelete(
      imageId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImageImagesImageIdDelete(imageId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ImageApi.deleteImageImagesImageIdDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes an image_id and a vm_id, and returns a detached_image  Args:     image_id (str): str - the id of the image to be detached     detach_info (str): str - the id of the VM to which the image is attached     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The detached image.
     * @summary Detach Image
     * @param {string} imageId Image id (UUID4)
     * @param {DetachImage} detachImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async detachImageImagesImageIdDetachDelete(
      imageId: string,
      detachImage: DetachImage,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.detachImageImagesImageIdDetachDelete(
        imageId,
        detachImage,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ImageApi.detachImageImagesImageIdDetachDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Returns the image with the specified id  It takes an image id, uses the ImageCrud dependency to get the image, and returns the image  Args:     image_id (str): str = Query(None, description=\"Image id\")     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the ImageCrud class will be instantiated and passed to     the function as a parameter.  Returns:     schemas.Image: The image is being returned.
     * @summary Get Image
     * @param {string} imageId Image id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getImageImagesImageIdGet(
      imageId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getImageImagesImageIdGet(imageId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ImageApi.getImageImagesImageIdGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It gets all the images from the database and returns them  Args:     storage_id: Storage id     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the function will receive an instance of ImageCrud class.  Returns:     Page[schemas.Image]: A list of images.
     * @summary Get Images
     * @param {string} [storageId] Storage id (UUID4)
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getImagesImagesGet(
      storageId?: string,
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageImage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getImagesImagesGet(storageId, page, size, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ImageApi.getImagesImagesGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Uploads an image to the storage.  It reads the image from the request, saves it to a temporary file, and then passes the file name to the `ImageCrud` class  Args:     storage_id (str): str - the id of the storage where the image will be     uploaded     name (str): str - the name of the image.     description (str): str - the description of the image.     image (UploadFile): UploadFile = File(...)     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The image object.
     * @summary Upload Image
     * @param {File} image Upload image.
     * @param {string} [description] Image description
     * @param {string} [storageId] Storage id (UUID4)
     * @param {string} [name] Image name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadImageImagesUploadPost(
      image: File,
      description?: string,
      storageId?: string,
      name?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImageImagesUploadPost(
        image,
        description,
        storageId,
        name,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['ImageApi.uploadImageImagesUploadPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ImageApiFp(configuration)
  return {
    /**
     * Attach an image to a VM  The first line of the function is a docstring. This is a string that describes what the function does. It\'s a good idea to include a docstring for every function you write  Args:     image_id (str): str - the id of the image to be attached     data (str): str - the id of the VM to which the image will be attached     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     schemas.AttachImageInfo: The attached image.
     * @summary Attach Image
     * @param {ImageApiAttachImageImagesImageIdAttachPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachImageImagesImageIdAttachPost(
      requestParameters: ImageApiAttachImageImagesImageIdAttachPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AttachImageInfo> {
      return localVarFp
        .attachImageImagesImageIdAttachPost(
          requestParameters.imageId,
          requestParameters.openvairModulesImageEntrypointsSchemasAttachImage,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * It deletes an image from the database  Args:     image_id (str): str - the image id to delete     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     JSONResponse(status_code=status.HTTP_200_OK, content=message)
     * @summary Delete Image
     * @param {ImageApiDeleteImageImagesImageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImageImagesImageIdDelete(
      requestParameters: ImageApiDeleteImageImagesImageIdDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .deleteImageImagesImageIdDelete(requestParameters.imageId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes an image_id and a vm_id, and returns a detached_image  Args:     image_id (str): str - the id of the image to be detached     detach_info (str): str - the id of the VM to which the image is attached     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The detached image.
     * @summary Detach Image
     * @param {ImageApiDetachImageImagesImageIdDetachDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachImageImagesImageIdDetachDelete(
      requestParameters: ImageApiDetachImageImagesImageIdDetachDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Image> {
      return localVarFp
        .detachImageImagesImageIdDetachDelete(requestParameters.imageId, requestParameters.detachImage, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Returns the image with the specified id  It takes an image id, uses the ImageCrud dependency to get the image, and returns the image  Args:     image_id (str): str = Query(None, description=\"Image id\")     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the ImageCrud class will be instantiated and passed to     the function as a parameter.  Returns:     schemas.Image: The image is being returned.
     * @summary Get Image
     * @param {ImageApiGetImageImagesImageIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImageImagesImageIdGet(
      requestParameters: ImageApiGetImageImagesImageIdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Image> {
      return localVarFp
        .getImageImagesImageIdGet(requestParameters.imageId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It gets all the images from the database and returns them  Args:     storage_id: Storage id     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the function will receive an instance of ImageCrud class.  Returns:     Page[schemas.Image]: A list of images.
     * @summary Get Images
     * @param {ImageApiGetImagesImagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImagesImagesGet(
      requestParameters: ImageApiGetImagesImagesGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageImage> {
      return localVarFp
        .getImagesImagesGet(requestParameters.storageId, requestParameters.page, requestParameters.size, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Uploads an image to the storage.  It reads the image from the request, saves it to a temporary file, and then passes the file name to the `ImageCrud` class  Args:     storage_id (str): str - the id of the storage where the image will be     uploaded     name (str): str - the name of the image.     description (str): str - the description of the image.     image (UploadFile): UploadFile = File(...)     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The image object.
     * @summary Upload Image
     * @param {ImageApiUploadImageImagesUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadImageImagesUploadPost(
      requestParameters: ImageApiUploadImageImagesUploadPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Image> {
      return localVarFp
        .uploadImageImagesUploadPost(
          requestParameters.image,
          requestParameters.description,
          requestParameters.storageId,
          requestParameters.name,
          options
        )
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for attachImageImagesImageIdAttachPost operation in ImageApi.
 * @export
 * @interface ImageApiAttachImageImagesImageIdAttachPostRequest
 */
export interface ImageApiAttachImageImagesImageIdAttachPostRequest {
  /**
   * Image id (UUID4)
   * @type {string}
   * @memberof ImageApiAttachImageImagesImageIdAttachPost
   */
  readonly imageId: string

  /**
   *
   * @type {OpenvairModulesImageEntrypointsSchemasAttachImage}
   * @memberof ImageApiAttachImageImagesImageIdAttachPost
   */
  readonly openvairModulesImageEntrypointsSchemasAttachImage: OpenvairModulesImageEntrypointsSchemasAttachImage
}

/**
 * Request parameters for deleteImageImagesImageIdDelete operation in ImageApi.
 * @export
 * @interface ImageApiDeleteImageImagesImageIdDeleteRequest
 */
export interface ImageApiDeleteImageImagesImageIdDeleteRequest {
  /**
   * Image id (UUID4)
   * @type {string}
   * @memberof ImageApiDeleteImageImagesImageIdDelete
   */
  readonly imageId: string
}

/**
 * Request parameters for detachImageImagesImageIdDetachDelete operation in ImageApi.
 * @export
 * @interface ImageApiDetachImageImagesImageIdDetachDeleteRequest
 */
export interface ImageApiDetachImageImagesImageIdDetachDeleteRequest {
  /**
   * Image id (UUID4)
   * @type {string}
   * @memberof ImageApiDetachImageImagesImageIdDetachDelete
   */
  readonly imageId: string

  /**
   *
   * @type {DetachImage}
   * @memberof ImageApiDetachImageImagesImageIdDetachDelete
   */
  readonly detachImage: DetachImage
}

/**
 * Request parameters for getImageImagesImageIdGet operation in ImageApi.
 * @export
 * @interface ImageApiGetImageImagesImageIdGetRequest
 */
export interface ImageApiGetImageImagesImageIdGetRequest {
  /**
   * Image id (UUID4)
   * @type {string}
   * @memberof ImageApiGetImageImagesImageIdGet
   */
  readonly imageId: string
}

/**
 * Request parameters for getImagesImagesGet operation in ImageApi.
 * @export
 * @interface ImageApiGetImagesImagesGetRequest
 */
export interface ImageApiGetImagesImagesGetRequest {
  /**
   * Storage id (UUID4)
   * @type {string}
   * @memberof ImageApiGetImagesImagesGet
   */
  readonly storageId?: string

  /**
   *
   * @type {number}
   * @memberof ImageApiGetImagesImagesGet
   */
  readonly page?: number

  /**
   *
   * @type {number}
   * @memberof ImageApiGetImagesImagesGet
   */
  readonly size?: number
}

/**
 * Request parameters for uploadImageImagesUploadPost operation in ImageApi.
 * @export
 * @interface ImageApiUploadImageImagesUploadPostRequest
 */
export interface ImageApiUploadImageImagesUploadPostRequest {
  /**
   * Upload image.
   * @type {File}
   * @memberof ImageApiUploadImageImagesUploadPost
   */
  readonly image: File

  /**
   * Image description
   * @type {string}
   * @memberof ImageApiUploadImageImagesUploadPost
   */
  readonly description?: string

  /**
   * Storage id (UUID4)
   * @type {string}
   * @memberof ImageApiUploadImageImagesUploadPost
   */
  readonly storageId?: string

  /**
   * Image name
   * @type {string}
   * @memberof ImageApiUploadImageImagesUploadPost
   */
  readonly name?: string
}

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
  /**
   * Attach an image to a VM  The first line of the function is a docstring. This is a string that describes what the function does. It\'s a good idea to include a docstring for every function you write  Args:     image_id (str): str - the id of the image to be attached     data (str): str - the id of the VM to which the image will be attached     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     schemas.AttachImageInfo: The attached image.
   * @summary Attach Image
   * @param {ImageApiAttachImageImagesImageIdAttachPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public attachImageImagesImageIdAttachPost(
    requestParameters: ImageApiAttachImageImagesImageIdAttachPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ImageApiFp(this.configuration)
      .attachImageImagesImageIdAttachPost(
        requestParameters.imageId,
        requestParameters.openvairModulesImageEntrypointsSchemasAttachImage,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It deletes an image from the database  Args:     image_id (str): str - the image id to delete     user_info: The dependency that check user was authorised     crud: This is the dependency that we created in the previous section.  Returns:     JSONResponse(status_code=status.HTTP_200_OK, content=message)
   * @summary Delete Image
   * @param {ImageApiDeleteImageImagesImageIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public deleteImageImagesImageIdDelete(
    requestParameters: ImageApiDeleteImageImagesImageIdDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ImageApiFp(this.configuration)
      .deleteImageImagesImageIdDelete(requestParameters.imageId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes an image_id and a vm_id, and returns a detached_image  Args:     image_id (str): str - the id of the image to be detached     detach_info (str): str - the id of the VM to which the image is attached     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The detached image.
   * @summary Detach Image
   * @param {ImageApiDetachImageImagesImageIdDetachDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public detachImageImagesImageIdDetachDelete(
    requestParameters: ImageApiDetachImageImagesImageIdDetachDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ImageApiFp(this.configuration)
      .detachImageImagesImageIdDetachDelete(requestParameters.imageId, requestParameters.detachImage, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Returns the image with the specified id  It takes an image id, uses the ImageCrud dependency to get the image, and returns the image  Args:     image_id (str): str = Query(None, description=\"Image id\")     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the ImageCrud class will be instantiated and passed to     the function as a parameter.  Returns:     schemas.Image: The image is being returned.
   * @summary Get Image
   * @param {ImageApiGetImageImagesImageIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public getImageImagesImageIdGet(
    requestParameters: ImageApiGetImageImagesImageIdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ImageApiFp(this.configuration)
      .getImageImagesImageIdGet(requestParameters.imageId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It gets all the images from the database and returns them  Args:     storage_id: Storage id     crud: Depends(ImageCrud) - this is a dependency injection. It means     that the function will receive an instance of ImageCrud class.  Returns:     Page[schemas.Image]: A list of images.
   * @summary Get Images
   * @param {ImageApiGetImagesImagesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public getImagesImagesGet(
    requestParameters: ImageApiGetImagesImagesGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return ImageApiFp(this.configuration)
      .getImagesImagesGet(requestParameters.storageId, requestParameters.page, requestParameters.size, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Uploads an image to the storage.  It reads the image from the request, saves it to a temporary file, and then passes the file name to the `ImageCrud` class  Args:     storage_id (str): str - the id of the storage where the image will be     uploaded     name (str): str - the name of the image.     description (str): str - the description of the image.     image (UploadFile): UploadFile = File(...)     user_info: The dependency that check user was authorised     crud: Depends(ImageCrud) - this is a dependency injection.  Returns:     schemas.Image: The image object.
   * @summary Upload Image
   * @param {ImageApiUploadImageImagesUploadPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public uploadImageImagesUploadPost(
    requestParameters: ImageApiUploadImageImagesUploadPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ImageApiFp(this.configuration)
      .uploadImageImagesUploadPost(
        requestParameters.image,
        requestParameters.description,
        requestParameters.storageId,
        requestParameters.name,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * InterfaceApi - axios parameter creator
 * @export
 */
export const InterfaceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * API endpoint for creating a network bridge.  Args:     data (schemas.BridgeCreate): Information about the bridge to be created.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.BridgeCreateResponse: Response containing information about the         created bridge.  Raises:     Exception: Any error that occurs during the process.
     * @summary Bridge Create
     * @param {BridgeCreate} bridgeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bridgeCreateInterfacesCreatePost: async (
      bridgeCreate: BridgeCreate,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bridgeCreate' is not null or undefined
      assertParamExists('bridgeCreateInterfacesCreatePost', 'bridgeCreate', bridgeCreate)
      const localVarPath = `/interfaces/create/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(bridgeCreate, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API endpoint for deleting a bridge.  Args:     data (schemas.BridgeDelete): Information about the bridge to delete.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[Dict]: A list of responses containing information about the deleted         bridges.  Raises:     Exception: Any error that occurs during the process.
     * @summary Bridge Delete
     * @param {BridgeDelete} bridgeDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bridgeDeleteInterfacesDeleteDelete: async (
      bridgeDelete: BridgeDelete,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bridgeDelete' is not null or undefined
      assertParamExists('bridgeDeleteInterfacesDeleteDelete', 'bridgeDelete', bridgeDelete)
      const localVarPath = `/interfaces/delete/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(bridgeDelete, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API endpoint for retrieving the list of network bridges.  Args:     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[str]: A list of network bridges.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Bridges List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBridgesListInterfacesBridgesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/interfaces/bridges/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API endpoint for retrieving current network interface data.  Args:     iface_id (str): Interface ID (UUID4).     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.Interface: Response containing information about the specified         network interface.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Interface
     * @param {string} ifaceId Interface ID (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterfaceInterfacesIfaceIdGet: async (
      ifaceId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ifaceId' is not null or undefined
      assertParamExists('getInterfaceInterfacesIfaceIdGet', 'ifaceId', ifaceId)
      const localVarPath = `/interfaces/{iface_id}/`.replace(`{${'iface_id'}}`, encodeURIComponent(String(ifaceId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * API endpoint for retrieving a list of all interfaces.  Args:     is_need_filter (Optional[bool], optional): Flag indicating whether to         apply filtering on interfaces. Defaults to False.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     Page[schemas.Interface]: A paginated list of interfaces retrieved from         the database.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Interfaces
     * @param {boolean} [isNeedFilter] Flag for filtering interfaces.
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterfacesInterfacesGet: async (
      isNeedFilter?: boolean,
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/interfaces/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (isNeedFilter !== undefined) {
        localVarQueryParameter['is_need_filter'] = isNeedFilter
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Turn off the specified interface.  This function sends a turn-off command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned off.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
     * @summary Turn Off Interface
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffInterfaceInterfacesNameTurnOffPut: async (
      name: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('turnOffInterfaceInterfacesNameTurnOffPut', 'name', name)
      const localVarPath = `/interfaces/{name}/turn_off`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Turn on the specified interface.  This function sends a turn-on command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned on.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
     * @summary Turn On Interface
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnInterfaceInterfacesNameTurnOnPut: async (
      name: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('turnOnInterfaceInterfacesNameTurnOnPut', 'name', name)
      const localVarPath = `/interfaces/{name}/turn_on`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * InterfaceApi - functional programming interface
 * @export
 */
export const InterfaceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = InterfaceApiAxiosParamCreator(configuration)
  return {
    /**
     * API endpoint for creating a network bridge.  Args:     data (schemas.BridgeCreate): Information about the bridge to be created.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.BridgeCreateResponse: Response containing information about the         created bridge.  Raises:     Exception: Any error that occurs during the process.
     * @summary Bridge Create
     * @param {BridgeCreate} bridgeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bridgeCreateInterfacesCreatePost(
      bridgeCreate: BridgeCreate,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BridgeCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bridgeCreateInterfacesCreatePost(bridgeCreate, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['InterfaceApi.bridgeCreateInterfacesCreatePost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * API endpoint for deleting a bridge.  Args:     data (schemas.BridgeDelete): Information about the bridge to delete.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[Dict]: A list of responses containing information about the deleted         bridges.  Raises:     Exception: Any error that occurs during the process.
     * @summary Bridge Delete
     * @param {BridgeDelete} bridgeDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bridgeDeleteInterfacesDeleteDelete(
      bridgeDelete: BridgeDelete,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bridgeDeleteInterfacesDeleteDelete(
        bridgeDelete,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['InterfaceApi.bridgeDeleteInterfacesDeleteDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * API endpoint for retrieving the list of network bridges.  Args:     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[str]: A list of network bridges.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Bridges List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBridgesListInterfacesBridgesGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBridgesListInterfacesBridgesGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['InterfaceApi.getBridgesListInterfacesBridgesGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * API endpoint for retrieving current network interface data.  Args:     iface_id (str): Interface ID (UUID4).     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.Interface: Response containing information about the specified         network interface.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Interface
     * @param {string} ifaceId Interface ID (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInterfaceInterfacesIfaceIdGet(
      ifaceId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInterfaceInterfacesIfaceIdGet(ifaceId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['InterfaceApi.getInterfaceInterfacesIfaceIdGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * API endpoint for retrieving a list of all interfaces.  Args:     is_need_filter (Optional[bool], optional): Flag indicating whether to         apply filtering on interfaces. Defaults to False.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     Page[schemas.Interface]: A paginated list of interfaces retrieved from         the database.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Interfaces
     * @param {boolean} [isNeedFilter] Flag for filtering interfaces.
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInterfacesInterfacesGet(
      isNeedFilter?: boolean,
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageInterface>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getInterfacesInterfacesGet(
        isNeedFilter,
        page,
        size,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['InterfaceApi.getInterfacesInterfacesGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Turn off the specified interface.  This function sends a turn-off command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned off.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
     * @summary Turn Off Interface
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async turnOffInterfaceInterfacesNameTurnOffPut(
      name: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.turnOffInterfaceInterfacesNameTurnOffPut(name, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['InterfaceApi.turnOffInterfaceInterfacesNameTurnOffPut']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Turn on the specified interface.  This function sends a turn-on command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned on.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
     * @summary Turn On Interface
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async turnOnInterfaceInterfacesNameTurnOnPut(
      name: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.turnOnInterfaceInterfacesNameTurnOnPut(name, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['InterfaceApi.turnOnInterfaceInterfacesNameTurnOnPut']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * InterfaceApi - factory interface
 * @export
 */
export const InterfaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = InterfaceApiFp(configuration)
  return {
    /**
     * API endpoint for creating a network bridge.  Args:     data (schemas.BridgeCreate): Information about the bridge to be created.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.BridgeCreateResponse: Response containing information about the         created bridge.  Raises:     Exception: Any error that occurs during the process.
     * @summary Bridge Create
     * @param {InterfaceApiBridgeCreateInterfacesCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bridgeCreateInterfacesCreatePost(
      requestParameters: InterfaceApiBridgeCreateInterfacesCreatePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BridgeCreateResponse> {
      return localVarFp
        .bridgeCreateInterfacesCreatePost(requestParameters.bridgeCreate, options)
        .then(request => request(axios, basePath))
    },
    /**
     * API endpoint for deleting a bridge.  Args:     data (schemas.BridgeDelete): Information about the bridge to delete.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[Dict]: A list of responses containing information about the deleted         bridges.  Raises:     Exception: Any error that occurs during the process.
     * @summary Bridge Delete
     * @param {InterfaceApiBridgeDeleteInterfacesDeleteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bridgeDeleteInterfacesDeleteDelete(
      requestParameters: InterfaceApiBridgeDeleteInterfacesDeleteDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .bridgeDeleteInterfacesDeleteDelete(requestParameters.bridgeDelete, options)
        .then(request => request(axios, basePath))
    },
    /**
     * API endpoint for retrieving the list of network bridges.  Args:     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[str]: A list of network bridges.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Bridges List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBridgesListInterfacesBridgesGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
      return localVarFp.getBridgesListInterfacesBridgesGet(options).then(request => request(axios, basePath))
    },
    /**
     * API endpoint for retrieving current network interface data.  Args:     iface_id (str): Interface ID (UUID4).     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.Interface: Response containing information about the specified         network interface.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Interface
     * @param {InterfaceApiGetInterfaceInterfacesIfaceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterfaceInterfacesIfaceIdGet(
      requestParameters: InterfaceApiGetInterfaceInterfacesIfaceIdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .getInterfaceInterfacesIfaceIdGet(requestParameters.ifaceId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * API endpoint for retrieving a list of all interfaces.  Args:     is_need_filter (Optional[bool], optional): Flag indicating whether to         apply filtering on interfaces. Defaults to False.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     Page[schemas.Interface]: A paginated list of interfaces retrieved from         the database.  Raises:     Exception: Any error that occurs during the process.
     * @summary Get Interfaces
     * @param {InterfaceApiGetInterfacesInterfacesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInterfacesInterfacesGet(
      requestParameters: InterfaceApiGetInterfacesInterfacesGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageInterface> {
      return localVarFp
        .getInterfacesInterfacesGet(
          requestParameters.isNeedFilter,
          requestParameters.page,
          requestParameters.size,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Turn off the specified interface.  This function sends a turn-off command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned off.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
     * @summary Turn Off Interface
     * @param {InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffInterfaceInterfacesNameTurnOffPut(
      requestParameters: InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPutRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .turnOffInterfaceInterfacesNameTurnOffPut(requestParameters.name, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Turn on the specified interface.  This function sends a turn-on command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned on.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
     * @summary Turn On Interface
     * @param {InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnInterfaceInterfacesNameTurnOnPut(
      requestParameters: InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPutRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .turnOnInterfaceInterfacesNameTurnOnPut(requestParameters.name, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for bridgeCreateInterfacesCreatePost operation in InterfaceApi.
 * @export
 * @interface InterfaceApiBridgeCreateInterfacesCreatePostRequest
 */
export interface InterfaceApiBridgeCreateInterfacesCreatePostRequest {
  /**
   *
   * @type {BridgeCreate}
   * @memberof InterfaceApiBridgeCreateInterfacesCreatePost
   */
  readonly bridgeCreate: BridgeCreate
}

/**
 * Request parameters for bridgeDeleteInterfacesDeleteDelete operation in InterfaceApi.
 * @export
 * @interface InterfaceApiBridgeDeleteInterfacesDeleteDeleteRequest
 */
export interface InterfaceApiBridgeDeleteInterfacesDeleteDeleteRequest {
  /**
   *
   * @type {BridgeDelete}
   * @memberof InterfaceApiBridgeDeleteInterfacesDeleteDelete
   */
  readonly bridgeDelete: BridgeDelete
}

/**
 * Request parameters for getInterfaceInterfacesIfaceIdGet operation in InterfaceApi.
 * @export
 * @interface InterfaceApiGetInterfaceInterfacesIfaceIdGetRequest
 */
export interface InterfaceApiGetInterfaceInterfacesIfaceIdGetRequest {
  /**
   * Interface ID (UUID4)
   * @type {string}
   * @memberof InterfaceApiGetInterfaceInterfacesIfaceIdGet
   */
  readonly ifaceId: string
}

/**
 * Request parameters for getInterfacesInterfacesGet operation in InterfaceApi.
 * @export
 * @interface InterfaceApiGetInterfacesInterfacesGetRequest
 */
export interface InterfaceApiGetInterfacesInterfacesGetRequest {
  /**
   * Flag for filtering interfaces.
   * @type {boolean}
   * @memberof InterfaceApiGetInterfacesInterfacesGet
   */
  readonly isNeedFilter?: boolean

  /**
   *
   * @type {number}
   * @memberof InterfaceApiGetInterfacesInterfacesGet
   */
  readonly page?: number

  /**
   *
   * @type {number}
   * @memberof InterfaceApiGetInterfacesInterfacesGet
   */
  readonly size?: number
}

/**
 * Request parameters for turnOffInterfaceInterfacesNameTurnOffPut operation in InterfaceApi.
 * @export
 * @interface InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPutRequest
 */
export interface InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPutRequest {
  /**
   *
   * @type {string}
   * @memberof InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPut
   */
  readonly name: string
}

/**
 * Request parameters for turnOnInterfaceInterfacesNameTurnOnPut operation in InterfaceApi.
 * @export
 * @interface InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPutRequest
 */
export interface InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPutRequest {
  /**
   *
   * @type {string}
   * @memberof InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPut
   */
  readonly name: string
}

/**
 * InterfaceApi - object-oriented interface
 * @export
 * @class InterfaceApi
 * @extends {BaseAPI}
 */
export class InterfaceApi extends BaseAPI {
  /**
   * API endpoint for creating a network bridge.  Args:     data (schemas.BridgeCreate): Information about the bridge to be created.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.BridgeCreateResponse: Response containing information about the         created bridge.  Raises:     Exception: Any error that occurs during the process.
   * @summary Bridge Create
   * @param {InterfaceApiBridgeCreateInterfacesCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public bridgeCreateInterfacesCreatePost(
    requestParameters: InterfaceApiBridgeCreateInterfacesCreatePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return InterfaceApiFp(this.configuration)
      .bridgeCreateInterfacesCreatePost(requestParameters.bridgeCreate, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * API endpoint for deleting a bridge.  Args:     data (schemas.BridgeDelete): Information about the bridge to delete.     user_info (Dict): User information retrieved from the authentication         token.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[Dict]: A list of responses containing information about the deleted         bridges.  Raises:     Exception: Any error that occurs during the process.
   * @summary Bridge Delete
   * @param {InterfaceApiBridgeDeleteInterfacesDeleteDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public bridgeDeleteInterfacesDeleteDelete(
    requestParameters: InterfaceApiBridgeDeleteInterfacesDeleteDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return InterfaceApiFp(this.configuration)
      .bridgeDeleteInterfacesDeleteDelete(requestParameters.bridgeDelete, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * API endpoint for retrieving the list of network bridges.  Args:     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     List[str]: A list of network bridges.  Raises:     Exception: Any error that occurs during the process.
   * @summary Get Bridges List
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public getBridgesListInterfacesBridgesGet(options?: RawAxiosRequestConfig) {
    return InterfaceApiFp(this.configuration)
      .getBridgesListInterfacesBridgesGet(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * API endpoint for retrieving current network interface data.  Args:     iface_id (str): Interface ID (UUID4).     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     schemas.Interface: Response containing information about the specified         network interface.  Raises:     Exception: Any error that occurs during the process.
   * @summary Get Interface
   * @param {InterfaceApiGetInterfaceInterfacesIfaceIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public getInterfaceInterfacesIfaceIdGet(
    requestParameters: InterfaceApiGetInterfaceInterfacesIfaceIdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return InterfaceApiFp(this.configuration)
      .getInterfaceInterfacesIfaceIdGet(requestParameters.ifaceId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * API endpoint for retrieving a list of all interfaces.  Args:     is_need_filter (Optional[bool], optional): Flag indicating whether to         apply filtering on interfaces. Defaults to False.     crud (InterfaceCrud, optional): Dependency injection for CRUD operations         on interfaces.  Returns:     Page[schemas.Interface]: A paginated list of interfaces retrieved from         the database.  Raises:     Exception: Any error that occurs during the process.
   * @summary Get Interfaces
   * @param {InterfaceApiGetInterfacesInterfacesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public getInterfacesInterfacesGet(
    requestParameters: InterfaceApiGetInterfacesInterfacesGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return InterfaceApiFp(this.configuration)
      .getInterfacesInterfacesGet(
        requestParameters.isNeedFilter,
        requestParameters.page,
        requestParameters.size,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Turn off the specified interface.  This function sends a turn-off command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned off.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
   * @summary Turn Off Interface
   * @param {InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public turnOffInterfaceInterfacesNameTurnOffPut(
    requestParameters: InterfaceApiTurnOffInterfaceInterfacesNameTurnOffPutRequest,
    options?: RawAxiosRequestConfig
  ) {
    return InterfaceApiFp(this.configuration)
      .turnOffInterfaceInterfacesNameTurnOffPut(requestParameters.name, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Turn on the specified interface.  This function sends a turn-on command for the specified network interface via the provided CRUD operations. The actual operation is run in a thread pool to avoid blocking the event loop.  Args:     name (str): The name of the network interface to be turned on.     crud (InterfaceCrud, optional): The CRUD operations dependency for         managing interfaces.  Returns:     JSONResponse: A JSON response with a success message and HTTP 200         status.
   * @summary Turn On Interface
   * @param {InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InterfaceApi
   */
  public turnOnInterfaceInterfacesNameTurnOnPut(
    requestParameters: InterfaceApiTurnOnInterfaceInterfacesNameTurnOnPutRequest,
    options?: RawAxiosRequestConfig
  ) {
    return InterfaceApiFp(this.configuration)
      .turnOnInterfaceInterfacesNameTurnOnPut(requestParameters.name, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Sends a notification of the appropriate type to the specified recipients  Args:     data: Information about the notification to send     crud: Injected the crud object for the notifications Returns:     The notification object from db with status code
     * @summary Send Notification
     * @param {Notification} notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendNotificationNotificationsSendPost: async (
      notification: Notification,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'notification' is not null or undefined
      assertParamExists('sendNotificationNotificationsSendPost', 'notification', notification)
      const localVarPath = `/notifications/send/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
  return {
    /**
     * Sends a notification of the appropriate type to the specified recipients  Args:     data: Information about the notification to send     crud: Injected the crud object for the notifications Returns:     The notification object from db with status code
     * @summary Send Notification
     * @param {Notification} notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendNotificationNotificationsSendPost(
      notification: Notification,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendNotificationNotificationsSendPost(
        notification,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['NotificationApi.sendNotificationNotificationsSendPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = NotificationApiFp(configuration)
  return {
    /**
     * Sends a notification of the appropriate type to the specified recipients  Args:     data: Information about the notification to send     crud: Injected the crud object for the notifications Returns:     The notification object from db with status code
     * @summary Send Notification
     * @param {NotificationApiSendNotificationNotificationsSendPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendNotificationNotificationsSendPost(
      requestParameters: NotificationApiSendNotificationNotificationsSendPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Notification> {
      return localVarFp
        .sendNotificationNotificationsSendPost(requestParameters.notification, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for sendNotificationNotificationsSendPost operation in NotificationApi.
 * @export
 * @interface NotificationApiSendNotificationNotificationsSendPostRequest
 */
export interface NotificationApiSendNotificationNotificationsSendPostRequest {
  /**
   *
   * @type {Notification}
   * @memberof NotificationApiSendNotificationNotificationsSendPost
   */
  readonly notification: Notification
}

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
  /**
   * Sends a notification of the appropriate type to the specified recipients  Args:     data: Information about the notification to send     crud: Injected the crud object for the notifications Returns:     The notification object from db with status code
   * @summary Send Notification
   * @param {NotificationApiSendNotificationNotificationsSendPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationApi
   */
  public sendNotificationNotificationsSendPost(
    requestParameters: NotificationApiSendNotificationNotificationsSendPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return NotificationApiFp(this.configuration)
      .sendNotificationNotificationsSendPost(requestParameters.notification, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * StorageApi - axios parameter creator
 * @export
 */
export const StorageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a local disk partition.  This endpoint creates a new partition on a local disk based on the provided data.  Args:     data (schemas.CreateLocalPartition): Data for creating the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     schemas.LocalDisk: Information about the newly created partition.
     * @summary Create Local Partition
     * @param {CreateLocalPartition} createLocalPartition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLocalPartitionStoragesLocalDisksCreatePartitionPost: async (
      createLocalPartition: CreateLocalPartition,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createLocalPartition' is not null or undefined
      assertParamExists(
        'createLocalPartitionStoragesLocalDisksCreatePartitionPost',
        'createLocalPartition',
        createLocalPartition
      )
      const localVarPath = `/storages/local-disks/create_partition/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createLocalPartition, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It creates a storage  Args:     data (schemas.CreateStorage): schemas.CreateStorage - this is the data     that will be passed to the function.     user_data: The dependency that check user was authorised     crud: StorageCrud - this is the dependency that we will inject into the     function.  Returns:     The storage object is being returned.
     * @summary Create Storage
     * @param {CreateStorage} createStorage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageStoragesCreatePost: async (
      createStorage: CreateStorage,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createStorage' is not null or undefined
      assertParamExists('createStorageStoragesCreatePost', 'createStorage', createStorage)
      const localVarPath = `/storages/create/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createStorage, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a local disk partition.  This endpoint deletes the specified local disk partition.  Args:     data (schemas.DeleteLocalPartition): Data for deleting the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     Dict: A message indicating the success of the operation.
     * @summary Delete Local Partition
     * @param {DeleteLocalPartition} deleteLocalPartition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete: async (
      deleteLocalPartition: DeleteLocalPartition,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteLocalPartition' is not null or undefined
      assertParamExists(
        'deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete',
        'deleteLocalPartition',
        deleteLocalPartition
      )
      const localVarPath = `/storages/local-disks/delete_partition/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(deleteLocalPartition, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It deletes a storage  Args:     storage_id (str): str = Query(None, description=\"Storage id\")     user_data: The dependency that check user was authorised     crud: Depends(StorageCrud)  Returns:     The storage object.
     * @summary Delete Storage
     * @param {string} storageId Storage id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStorageStoragesStorageIdDeleteDelete: async (
      storageId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'storageId' is not null or undefined
      assertParamExists('deleteStorageStoragesStorageIdDeleteDelete', 'storageId', storageId)
      const localVarPath = `/storages/{storage_id}/delete/`.replace(
        `{${'storage_id'}}`,
        encodeURIComponent(String(storageId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get information about local disk partitions.  This endpoint retrieves information about partitions on a specified local disk.  Args:     disk_path (str): Path to the local disk.     unit (Optional[str]): unit of values about partitions     crud (StorageCrud): Dependency for CRUD operations.  Returns:     Dict: Information about local disk partitions.
     * @summary Get Local Disk Partitions Info
     * @param {string} diskPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet: async (
      diskPath: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'diskPath' is not null or undefined
      assertParamExists('getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet', 'diskPath', diskPath)
      const localVarPath = `/storages/local-disks/partition_info/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (diskPath !== undefined) {
        localVarQueryParameter['disk_path'] = diskPath
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It gets a list of free local disks  Args:     free_local_disks: flag on get free local disks     crud: This is the dependency that we created earlier.  Returns:     A list of free local disks.
     * @summary Get Local Disks
     * @param {boolean} [freeLocalDisks]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalDisksStoragesLocalDisksGet: async (
      freeLocalDisks?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/storages/local-disks/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (freeLocalDisks !== undefined) {
        localVarQueryParameter['free_local_disks'] = freeLocalDisks
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It gets a storage by id  Args:     storage_id (str): str = Query(None, description=\"Volume id\")     crud: Depends(StorageCrud) - this is a dependency injection.  Returns:     The storage object.
     * @summary Get Storage
     * @param {string} storageId Storage id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageStoragesStorageIdGet: async (
      storageId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'storageId' is not null or undefined
      assertParamExists('getStorageStoragesStorageIdGet', 'storageId', storageId)
      const localVarPath = `/storages/{storage_id}/`.replace(`{${'storage_id'}}`, encodeURIComponent(String(storageId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It gets a list of storages from the database  Args:   crud: Depends (StorageCrud) - this is a dependency injection.  Returns:   A list of storages.
     * @summary Get Storages
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStoragesStoragesGet: async (
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/storages/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StorageApi - functional programming interface
 * @export
 */
export const StorageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a local disk partition.  This endpoint creates a new partition on a local disk based on the provided data.  Args:     data (schemas.CreateLocalPartition): Data for creating the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     schemas.LocalDisk: Information about the newly created partition.
     * @summary Create Local Partition
     * @param {CreateLocalPartition} createLocalPartition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLocalPartitionStoragesLocalDisksCreatePartitionPost(
      createLocalPartition: CreateLocalPartition,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalDisk>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createLocalPartitionStoragesLocalDisksCreatePartitionPost(
          createLocalPartition,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['StorageApi.createLocalPartitionStoragesLocalDisksCreatePartitionPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It creates a storage  Args:     data (schemas.CreateStorage): schemas.CreateStorage - this is the data     that will be passed to the function.     user_data: The dependency that check user was authorised     crud: StorageCrud - this is the dependency that we will inject into the     function.  Returns:     The storage object is being returned.
     * @summary Create Storage
     * @param {CreateStorage} createStorage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStorageStoragesCreatePost(
      createStorage: CreateStorage,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStorageStoragesCreatePost(createStorage, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['StorageApi.createStorageStoragesCreatePost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Delete a local disk partition.  This endpoint deletes the specified local disk partition.  Args:     data (schemas.DeleteLocalPartition): Data for deleting the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     Dict: A message indicating the success of the operation.
     * @summary Delete Local Partition
     * @param {DeleteLocalPartition} deleteLocalPartition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete(
      deleteLocalPartition: DeleteLocalPartition,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete(
          deleteLocalPartition,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['StorageApi.deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It deletes a storage  Args:     storage_id (str): str = Query(None, description=\"Storage id\")     user_data: The dependency that check user was authorised     crud: Depends(StorageCrud)  Returns:     The storage object.
     * @summary Delete Storage
     * @param {string} storageId Storage id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStorageStoragesStorageIdDeleteDelete(
      storageId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStorageStoragesStorageIdDeleteDelete(
        storageId,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['StorageApi.deleteStorageStoragesStorageIdDeleteDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get information about local disk partitions.  This endpoint retrieves information about partitions on a specified local disk.  Args:     disk_path (str): Path to the local disk.     unit (Optional[str]): unit of values about partitions     crud (StorageCrud): Dependency for CRUD operations.  Returns:     Dict: Information about local disk partitions.
     * @summary Get Local Disk Partitions Info
     * @param {string} diskPath
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet(
      diskPath: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet(diskPath, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['StorageApi.getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It gets a list of free local disks  Args:     free_local_disks: flag on get free local disks     crud: This is the dependency that we created earlier.  Returns:     A list of free local disks.
     * @summary Get Local Disks
     * @param {boolean} [freeLocalDisks]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLocalDisksStoragesLocalDisksGet(
      freeLocalDisks?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfLocalDisks>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLocalDisksStoragesLocalDisksGet(
        freeLocalDisks,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['StorageApi.getLocalDisksStoragesLocalDisksGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It gets a storage by id  Args:     storage_id (str): str = Query(None, description=\"Volume id\")     crud: Depends(StorageCrud) - this is a dependency injection.  Returns:     The storage object.
     * @summary Get Storage
     * @param {string} storageId Storage id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStorageStoragesStorageIdGet(
      storageId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageStoragesStorageIdGet(storageId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['StorageApi.getStorageStoragesStorageIdGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It gets a list of storages from the database  Args:   crud: Depends (StorageCrud) - this is a dependency injection.  Returns:   A list of storages.
     * @summary Get Storages
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStoragesStoragesGet(
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageStorage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStoragesStoragesGet(page, size, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['StorageApi.getStoragesStoragesGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * StorageApi - factory interface
 * @export
 */
export const StorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = StorageApiFp(configuration)
  return {
    /**
     * Create a local disk partition.  This endpoint creates a new partition on a local disk based on the provided data.  Args:     data (schemas.CreateLocalPartition): Data for creating the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     schemas.LocalDisk: Information about the newly created partition.
     * @summary Create Local Partition
     * @param {StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLocalPartitionStoragesLocalDisksCreatePartitionPost(
      requestParameters: StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<LocalDisk> {
      return localVarFp
        .createLocalPartitionStoragesLocalDisksCreatePartitionPost(requestParameters.createLocalPartition, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It creates a storage  Args:     data (schemas.CreateStorage): schemas.CreateStorage - this is the data     that will be passed to the function.     user_data: The dependency that check user was authorised     crud: StorageCrud - this is the dependency that we will inject into the     function.  Returns:     The storage object is being returned.
     * @summary Create Storage
     * @param {StorageApiCreateStorageStoragesCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageStoragesCreatePost(
      requestParameters: StorageApiCreateStorageStoragesCreatePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Storage> {
      return localVarFp
        .createStorageStoragesCreatePost(requestParameters.createStorage, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Delete a local disk partition.  This endpoint deletes the specified local disk partition.  Args:     data (schemas.DeleteLocalPartition): Data for deleting the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     Dict: A message indicating the success of the operation.
     * @summary Delete Local Partition
     * @param {StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete(
      requestParameters: StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete(requestParameters.deleteLocalPartition, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It deletes a storage  Args:     storage_id (str): str = Query(None, description=\"Storage id\")     user_data: The dependency that check user was authorised     crud: Depends(StorageCrud)  Returns:     The storage object.
     * @summary Delete Storage
     * @param {StorageApiDeleteStorageStoragesStorageIdDeleteDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStorageStoragesStorageIdDeleteDelete(
      requestParameters: StorageApiDeleteStorageStoragesStorageIdDeleteDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Storage> {
      return localVarFp
        .deleteStorageStoragesStorageIdDeleteDelete(requestParameters.storageId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get information about local disk partitions.  This endpoint retrieves information about partitions on a specified local disk.  Args:     disk_path (str): Path to the local disk.     unit (Optional[str]): unit of values about partitions     crud (StorageCrud): Dependency for CRUD operations.  Returns:     Dict: Information about local disk partitions.
     * @summary Get Local Disk Partitions Info
     * @param {StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet(
      requestParameters: StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet(requestParameters.diskPath, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It gets a list of free local disks  Args:     free_local_disks: flag on get free local disks     crud: This is the dependency that we created earlier.  Returns:     A list of free local disks.
     * @summary Get Local Disks
     * @param {StorageApiGetLocalDisksStoragesLocalDisksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLocalDisksStoragesLocalDisksGet(
      requestParameters: StorageApiGetLocalDisksStoragesLocalDisksGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ListOfLocalDisks> {
      return localVarFp
        .getLocalDisksStoragesLocalDisksGet(requestParameters.freeLocalDisks, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It gets a storage by id  Args:     storage_id (str): str = Query(None, description=\"Volume id\")     crud: Depends(StorageCrud) - this is a dependency injection.  Returns:     The storage object.
     * @summary Get Storage
     * @param {StorageApiGetStorageStoragesStorageIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageStoragesStorageIdGet(
      requestParameters: StorageApiGetStorageStoragesStorageIdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Storage> {
      return localVarFp
        .getStorageStoragesStorageIdGet(requestParameters.storageId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It gets a list of storages from the database  Args:   crud: Depends (StorageCrud) - this is a dependency injection.  Returns:   A list of storages.
     * @summary Get Storages
     * @param {StorageApiGetStoragesStoragesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStoragesStoragesGet(
      requestParameters: StorageApiGetStoragesStoragesGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageStorage> {
      return localVarFp
        .getStoragesStoragesGet(requestParameters.page, requestParameters.size, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for createLocalPartitionStoragesLocalDisksCreatePartitionPost operation in StorageApi.
 * @export
 * @interface StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPostRequest
 */
export interface StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPostRequest {
  /**
   *
   * @type {CreateLocalPartition}
   * @memberof StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPost
   */
  readonly createLocalPartition: CreateLocalPartition
}

/**
 * Request parameters for createStorageStoragesCreatePost operation in StorageApi.
 * @export
 * @interface StorageApiCreateStorageStoragesCreatePostRequest
 */
export interface StorageApiCreateStorageStoragesCreatePostRequest {
  /**
   *
   * @type {CreateStorage}
   * @memberof StorageApiCreateStorageStoragesCreatePost
   */
  readonly createStorage: CreateStorage
}

/**
 * Request parameters for deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete operation in StorageApi.
 * @export
 * @interface StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDeleteRequest
 */
export interface StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDeleteRequest {
  /**
   *
   * @type {DeleteLocalPartition}
   * @memberof StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDelete
   */
  readonly deleteLocalPartition: DeleteLocalPartition
}

/**
 * Request parameters for deleteStorageStoragesStorageIdDeleteDelete operation in StorageApi.
 * @export
 * @interface StorageApiDeleteStorageStoragesStorageIdDeleteDeleteRequest
 */
export interface StorageApiDeleteStorageStoragesStorageIdDeleteDeleteRequest {
  /**
   * Storage id
   * @type {string}
   * @memberof StorageApiDeleteStorageStoragesStorageIdDeleteDelete
   */
  readonly storageId: string
}

/**
 * Request parameters for getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet operation in StorageApi.
 * @export
 * @interface StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGetRequest
 */
export interface StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGetRequest {
  /**
   *
   * @type {string}
   * @memberof StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet
   */
  readonly diskPath: string
}

/**
 * Request parameters for getLocalDisksStoragesLocalDisksGet operation in StorageApi.
 * @export
 * @interface StorageApiGetLocalDisksStoragesLocalDisksGetRequest
 */
export interface StorageApiGetLocalDisksStoragesLocalDisksGetRequest {
  /**
   *
   * @type {boolean}
   * @memberof StorageApiGetLocalDisksStoragesLocalDisksGet
   */
  readonly freeLocalDisks?: boolean
}

/**
 * Request parameters for getStorageStoragesStorageIdGet operation in StorageApi.
 * @export
 * @interface StorageApiGetStorageStoragesStorageIdGetRequest
 */
export interface StorageApiGetStorageStoragesStorageIdGetRequest {
  /**
   * Storage id
   * @type {string}
   * @memberof StorageApiGetStorageStoragesStorageIdGet
   */
  readonly storageId: string
}

/**
 * Request parameters for getStoragesStoragesGet operation in StorageApi.
 * @export
 * @interface StorageApiGetStoragesStoragesGetRequest
 */
export interface StorageApiGetStoragesStoragesGetRequest {
  /**
   *
   * @type {number}
   * @memberof StorageApiGetStoragesStoragesGet
   */
  readonly page?: number

  /**
   *
   * @type {number}
   * @memberof StorageApiGetStoragesStoragesGet
   */
  readonly size?: number
}

/**
 * StorageApi - object-oriented interface
 * @export
 * @class StorageApi
 * @extends {BaseAPI}
 */
export class StorageApi extends BaseAPI {
  /**
   * Create a local disk partition.  This endpoint creates a new partition on a local disk based on the provided data.  Args:     data (schemas.CreateLocalPartition): Data for creating the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     schemas.LocalDisk: Information about the newly created partition.
   * @summary Create Local Partition
   * @param {StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public createLocalPartitionStoragesLocalDisksCreatePartitionPost(
    requestParameters: StorageApiCreateLocalPartitionStoragesLocalDisksCreatePartitionPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .createLocalPartitionStoragesLocalDisksCreatePartitionPost(requestParameters.createLocalPartition, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It creates a storage  Args:     data (schemas.CreateStorage): schemas.CreateStorage - this is the data     that will be passed to the function.     user_data: The dependency that check user was authorised     crud: StorageCrud - this is the dependency that we will inject into the     function.  Returns:     The storage object is being returned.
   * @summary Create Storage
   * @param {StorageApiCreateStorageStoragesCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public createStorageStoragesCreatePost(
    requestParameters: StorageApiCreateStorageStoragesCreatePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .createStorageStoragesCreatePost(requestParameters.createStorage, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Delete a local disk partition.  This endpoint deletes the specified local disk partition.  Args:     data (schemas.DeleteLocalPartition): Data for deleting the partition.     crud (StorageCrud): Dependency for CRUD operations.     user_data (Dict): User data  Returns:     Dict: A message indicating the success of the operation.
   * @summary Delete Local Partition
   * @param {StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete(
    requestParameters: StorageApiDeleteLocalPartitionStoragesLocalDisksDeletePartitionDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .deleteLocalPartitionStoragesLocalDisksDeletePartitionDelete(requestParameters.deleteLocalPartition, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It deletes a storage  Args:     storage_id (str): str = Query(None, description=\"Storage id\")     user_data: The dependency that check user was authorised     crud: Depends(StorageCrud)  Returns:     The storage object.
   * @summary Delete Storage
   * @param {StorageApiDeleteStorageStoragesStorageIdDeleteDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public deleteStorageStoragesStorageIdDeleteDelete(
    requestParameters: StorageApiDeleteStorageStoragesStorageIdDeleteDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .deleteStorageStoragesStorageIdDeleteDelete(requestParameters.storageId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get information about local disk partitions.  This endpoint retrieves information about partitions on a specified local disk.  Args:     disk_path (str): Path to the local disk.     unit (Optional[str]): unit of values about partitions     crud (StorageCrud): Dependency for CRUD operations.  Returns:     Dict: Information about local disk partitions.
   * @summary Get Local Disk Partitions Info
   * @param {StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet(
    requestParameters: StorageApiGetLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .getLocalDiskPartitionsInfoStoragesLocalDisksPartitionInfoGet(requestParameters.diskPath, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It gets a list of free local disks  Args:     free_local_disks: flag on get free local disks     crud: This is the dependency that we created earlier.  Returns:     A list of free local disks.
   * @summary Get Local Disks
   * @param {StorageApiGetLocalDisksStoragesLocalDisksGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public getLocalDisksStoragesLocalDisksGet(
    requestParameters: StorageApiGetLocalDisksStoragesLocalDisksGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .getLocalDisksStoragesLocalDisksGet(requestParameters.freeLocalDisks, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It gets a storage by id  Args:     storage_id (str): str = Query(None, description=\"Volume id\")     crud: Depends(StorageCrud) - this is a dependency injection.  Returns:     The storage object.
   * @summary Get Storage
   * @param {StorageApiGetStorageStoragesStorageIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public getStorageStoragesStorageIdGet(
    requestParameters: StorageApiGetStorageStoragesStorageIdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .getStorageStoragesStorageIdGet(requestParameters.storageId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It gets a list of storages from the database  Args:   crud: Depends (StorageCrud) - this is a dependency injection.  Returns:   A list of storages.
   * @summary Get Storages
   * @param {StorageApiGetStoragesStoragesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageApi
   */
  public getStoragesStoragesGet(
    requestParameters: StorageApiGetStoragesStoragesGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return StorageApiFp(this.configuration)
      .getStoragesStoragesGet(requestParameters.page, requestParameters.size, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change the password for a user.  Args:     data: New password data.     user_id: The ID of the user whose password is to be changed.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The user\'s updated information after changing the         password.
     * @summary Change Password
     * @param {string} userId
     * @param {UserChangePassword} userChangePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePasswordUserUserIdChangePasswordPost: async (
      userId: string,
      userChangePassword: UserChangePassword,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('changePasswordUserUserIdChangePasswordPost', 'userId', userId)
      // verify required parameter 'userChangePassword' is not null or undefined
      assertParamExists('changePasswordUserUserIdChangePasswordPost', 'userChangePassword', userChangePassword)
      const localVarPath = `/user/{user_id}/change-password/`.replace(
        `{${'user_id'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(userChangePassword, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create a new user and return the user\'s credentials.  Args:     data: User creation data including username, password, and email.     user_id: The ID of the current user (must be a superuser to create         new users).     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The created user\'s credentials.
     * @summary Create User
     * @param {string} userId
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUserUserIdCreatePost: async (
      userId: string,
      userCreate: UserCreate,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('createUserUserUserIdCreatePost', 'userId', userId)
      // verify required parameter 'userCreate' is not null or undefined
      assertParamExists('createUserUserUserIdCreatePost', 'userCreate', userCreate)
      const localVarPath = `/user/{user_id}/create/`.replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete a user from the database.  Args:     user_id: The ID of the user to be deleted.     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.UserDelete: Result of the delete operation.
     * @summary Delete User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserUserUserIdDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('deleteUserUserUserIdDelete', 'userId', userId)
      const localVarPath = `/user/{user_id}/`.replace(`{${'user_id'}}`, encodeURIComponent(String(userId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieve current authenticated user information.  Args:     crud: UserCrud instance for performing CRUD operations.     user_dict: Dictionary containing current authenticated user data.  Returns:     schemas.User: The current authenticated user\'s information.
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/user/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      // authentication HTTPBearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Change the password for a user.  Args:     data: New password data.     user_id: The ID of the user whose password is to be changed.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The user\'s updated information after changing the         password.
     * @summary Change Password
     * @param {string} userId
     * @param {UserChangePassword} userChangePassword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePasswordUserUserIdChangePasswordPost(
      userId: string,
      userChangePassword: UserChangePassword,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordUserUserIdChangePasswordPost(
        userId,
        userChangePassword,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.changePasswordUserUserIdChangePasswordPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Create a new user and return the user\'s credentials.  Args:     data: User creation data including username, password, and email.     user_id: The ID of the current user (must be a superuser to create         new users).     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The created user\'s credentials.
     * @summary Create User
     * @param {string} userId
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserUserUserIdCreatePost(
      userId: string,
      userCreate: UserCreate,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserUserUserIdCreatePost(
        userId,
        userCreate,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.createUserUserUserIdCreatePost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Delete a user from the database.  Args:     user_id: The ID of the user to be deleted.     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.UserDelete: Result of the delete operation.
     * @summary Delete User
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserUserUserIdDelete(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDelete>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserUserUserIdDelete(userId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.deleteUserUserUserIdDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieve current authenticated user information.  Args:     crud: UserCrud instance for performing CRUD operations.     user_dict: Dictionary containing current authenticated user data.  Returns:     schemas.User: The current authenticated user\'s information.
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUserGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUserGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['UserApi.getUserUserGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration)
  return {
    /**
     * Change the password for a user.  Args:     data: New password data.     user_id: The ID of the user whose password is to be changed.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The user\'s updated information after changing the         password.
     * @summary Change Password
     * @param {UserApiChangePasswordUserUserIdChangePasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePasswordUserUserIdChangePasswordPost(
      requestParameters: UserApiChangePasswordUserUserIdChangePasswordPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .changePasswordUserUserIdChangePasswordPost(
          requestParameters.userId,
          requestParameters.userChangePassword,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Create a new user and return the user\'s credentials.  Args:     data: User creation data including username, password, and email.     user_id: The ID of the current user (must be a superuser to create         new users).     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The created user\'s credentials.
     * @summary Create User
     * @param {UserApiCreateUserUserUserIdCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUserUserIdCreatePost(
      requestParameters: UserApiCreateUserUserUserIdCreatePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<User> {
      return localVarFp
        .createUserUserUserIdCreatePost(requestParameters.userId, requestParameters.userCreate, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Delete a user from the database.  Args:     user_id: The ID of the user to be deleted.     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.UserDelete: Result of the delete operation.
     * @summary Delete User
     * @param {UserApiDeleteUserUserUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserUserUserIdDelete(
      requestParameters: UserApiDeleteUserUserUserIdDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<UserDelete> {
      return localVarFp
        .deleteUserUserUserIdDelete(requestParameters.userId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieve current authenticated user information.  Args:     crud: UserCrud instance for performing CRUD operations.     user_dict: Dictionary containing current authenticated user data.  Returns:     schemas.User: The current authenticated user\'s information.
     * @summary Get User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUserGet(options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp.getUserUserGet(options).then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for changePasswordUserUserIdChangePasswordPost operation in UserApi.
 * @export
 * @interface UserApiChangePasswordUserUserIdChangePasswordPostRequest
 */
export interface UserApiChangePasswordUserUserIdChangePasswordPostRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiChangePasswordUserUserIdChangePasswordPost
   */
  readonly userId: string

  /**
   *
   * @type {UserChangePassword}
   * @memberof UserApiChangePasswordUserUserIdChangePasswordPost
   */
  readonly userChangePassword: UserChangePassword
}

/**
 * Request parameters for createUserUserUserIdCreatePost operation in UserApi.
 * @export
 * @interface UserApiCreateUserUserUserIdCreatePostRequest
 */
export interface UserApiCreateUserUserUserIdCreatePostRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiCreateUserUserUserIdCreatePost
   */
  readonly userId: string

  /**
   *
   * @type {UserCreate}
   * @memberof UserApiCreateUserUserUserIdCreatePost
   */
  readonly userCreate: UserCreate
}

/**
 * Request parameters for deleteUserUserUserIdDelete operation in UserApi.
 * @export
 * @interface UserApiDeleteUserUserUserIdDeleteRequest
 */
export interface UserApiDeleteUserUserUserIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof UserApiDeleteUserUserUserIdDelete
   */
  readonly userId: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * Change the password for a user.  Args:     data: New password data.     user_id: The ID of the user whose password is to be changed.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The user\'s updated information after changing the         password.
   * @summary Change Password
   * @param {UserApiChangePasswordUserUserIdChangePasswordPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public changePasswordUserUserIdChangePasswordPost(
    requestParameters: UserApiChangePasswordUserUserIdChangePasswordPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .changePasswordUserUserIdChangePasswordPost(
        requestParameters.userId,
        requestParameters.userChangePassword,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Create a new user and return the user\'s credentials.  Args:     data: User creation data including username, password, and email.     user_id: The ID of the current user (must be a superuser to create         new users).     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.User: The created user\'s credentials.
   * @summary Create User
   * @param {UserApiCreateUserUserUserIdCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public createUserUserUserIdCreatePost(
    requestParameters: UserApiCreateUserUserUserIdCreatePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .createUserUserUserIdCreatePost(requestParameters.userId, requestParameters.userCreate, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Delete a user from the database.  Args:     user_id: The ID of the user to be deleted.     user_data: Current authenticated user data.     crud: UserCrud instance for performing CRUD operations.  Returns:     schemas.UserDelete: Result of the delete operation.
   * @summary Delete User
   * @param {UserApiDeleteUserUserUserIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUserUserUserIdDelete(
    requestParameters: UserApiDeleteUserUserUserIdDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .deleteUserUserUserIdDelete(requestParameters.userId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieve current authenticated user information.  Args:     crud: UserCrud instance for performing CRUD operations.     user_dict: Dictionary containing current authenticated user data.  Returns:     schemas.User: The current authenticated user\'s information.
   * @summary Get User
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserUserGet(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .getUserUserGet(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VirtualMachineApi - axios parameter creator
 * @export
 */
export const VirtualMachineApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * It creates a virtual machine  Args:   data (schemas.CreateVirtualMachine): schemas.CreateVirtualMachine - this     is the data that will be passed to the function.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection. It means that the     function will be called with the VMCrud object.  Returns:   The return value is a dict.
     * @summary Create Vm
     * @param {CreateVirtualMachine} createVirtualMachine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVmVirtualMachinesCreatePost: async (
      createVirtualMachine: CreateVirtualMachine,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createVirtualMachine' is not null or undefined
      assertParamExists('createVmVirtualMachinesCreatePost', 'createVirtualMachine', createVirtualMachine)
      const localVarPath = `/virtual-machines/create/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createVirtualMachine, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a VM ID, uses the CRUD object to delete the VM, and returns the VM object  Args:   vm_id (str): str - the id of the VM to be deleted.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object that was deleted.
     * @summary Delete Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVmVirtualMachinesVmIdDelete: async (
      vmId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vmId' is not null or undefined
      assertParamExists('deleteVmVirtualMachinesVmIdDelete', 'vmId', vmId)
      const localVarPath = `/virtual-machines/{vm_id}/`.replace(`{${'vm_id'}}`, encodeURIComponent(String(vmId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a VM ID, and returns a VM object  Args:   vm_id (str): str - the id of the virtual machine to be edited.   data (str): schemas.VmEdit - edit data.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Edit Vm
     * @param {string} vmId
     * @param {EditVm} editVm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editVmVirtualMachinesVmIdEditPost: async (
      vmId: string,
      editVm: EditVm,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vmId' is not null or undefined
      assertParamExists('editVmVirtualMachinesVmIdEditPost', 'vmId', vmId)
      // verify required parameter 'editVm' is not null or undefined
      assertParamExists('editVmVirtualMachinesVmIdEditPost', 'editVm', editVm)
      const localVarPath = `/virtual-machines/{vm_id}/edit/`.replace(`{${'vm_id'}}`, encodeURIComponent(String(vmId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(editVm, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a VM id as an argument, and returns a VM object  Args:   vm_id (Optional[str]): Optional[str] = Query(None, description=\"VM id\")   crud: Depends(VMCrud)  Returns:   Vm.
     * @summary Get Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVmVirtualMachinesVmIdGet: async (vmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'vmId' is not null or undefined
      assertParamExists('getVmVirtualMachinesVmIdGet', 'vmId', vmId)
      const localVarPath = `/virtual-machines/{vm_id}/`.replace(`{${'vm_id'}}`, encodeURIComponent(String(vmId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It gets all the vms from the database and returns them  Args:   crud: This is the dependency that we created in the previous section.  Returns:   A list of all vms.
     * @summary Get Vms
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVmsVirtualMachinesGet: async (
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/virtual-machines/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a VM ID, shut off the VM, and returns the VM  Args:   vm_id (str): str - the id of the VM to be turned off.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Shut Off Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutOffVmVirtualMachinesVmIdShutOffPost: async (
      vmId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vmId' is not null or undefined
      assertParamExists('shutOffVmVirtualMachinesVmIdShutOffPost', 'vmId', vmId)
      const localVarPath = `/virtual-machines/{vm_id}/shut-off/`.replace(
        `{${'vm_id'}}`,
        encodeURIComponent(String(vmId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It starts a VM  Args:   vm_id (str): str - the id of the VM to start.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Start Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startVmVirtualMachinesVmIdStartPost: async (
      vmId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vmId' is not null or undefined
      assertParamExists('startVmVirtualMachinesVmIdStartPost', 'vmId', vmId)
      const localVarPath = `/virtual-machines/{vm_id}/start/`.replace(`{${'vm_id'}}`, encodeURIComponent(String(vmId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Vnc Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vncVmVirtualMachinesVmIdVncGet: async (vmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'vmId' is not null or undefined
      assertParamExists('vncVmVirtualMachinesVmIdVncGet', 'vmId', vmId)
      const localVarPath = `/virtual-machines/{vm_id}/vnc/`.replace(`{${'vm_id'}}`, encodeURIComponent(String(vmId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VirtualMachineApi - functional programming interface
 * @export
 */
export const VirtualMachineApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VirtualMachineApiAxiosParamCreator(configuration)
  return {
    /**
     * It creates a virtual machine  Args:   data (schemas.CreateVirtualMachine): schemas.CreateVirtualMachine - this     is the data that will be passed to the function.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection. It means that the     function will be called with the VMCrud object.  Returns:   The return value is a dict.
     * @summary Create Vm
     * @param {CreateVirtualMachine} createVirtualMachine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createVmVirtualMachinesCreatePost(
      createVirtualMachine: CreateVirtualMachine,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createVmVirtualMachinesCreatePost(
        createVirtualMachine,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VirtualMachineApi.createVmVirtualMachinesCreatePost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a VM ID, uses the CRUD object to delete the VM, and returns the VM object  Args:   vm_id (str): str - the id of the VM to be deleted.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object that was deleted.
     * @summary Delete Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVmVirtualMachinesVmIdDelete(
      vmId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVmVirtualMachinesVmIdDelete(vmId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VirtualMachineApi.deleteVmVirtualMachinesVmIdDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a VM ID, and returns a VM object  Args:   vm_id (str): str - the id of the virtual machine to be edited.   data (str): schemas.VmEdit - edit data.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Edit Vm
     * @param {string} vmId
     * @param {EditVm} editVm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editVmVirtualMachinesVmIdEditPost(
      vmId: string,
      editVm: EditVm,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editVmVirtualMachinesVmIdEditPost(vmId, editVm, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VirtualMachineApi.editVmVirtualMachinesVmIdEditPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a VM id as an argument, and returns a VM object  Args:   vm_id (Optional[str]): Optional[str] = Query(None, description=\"VM id\")   crud: Depends(VMCrud)  Returns:   Vm.
     * @summary Get Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVmVirtualMachinesVmIdGet(
      vmId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVmVirtualMachinesVmIdGet(vmId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VirtualMachineApi.getVmVirtualMachinesVmIdGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It gets all the vms from the database and returns them  Args:   crud: This is the dependency that we created in the previous section.  Returns:   A list of all vms.
     * @summary Get Vms
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVmsVirtualMachinesGet(
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageVirtualMachineInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVmsVirtualMachinesGet(page, size, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VirtualMachineApi.getVmsVirtualMachinesGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a VM ID, shut off the VM, and returns the VM  Args:   vm_id (str): str - the id of the VM to be turned off.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Shut Off Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async shutOffVmVirtualMachinesVmIdShutOffPost(
      vmId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.shutOffVmVirtualMachinesVmIdShutOffPost(vmId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualMachineApi.shutOffVmVirtualMachinesVmIdShutOffPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It starts a VM  Args:   vm_id (str): str - the id of the VM to start.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Start Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startVmVirtualMachinesVmIdStartPost(
      vmId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startVmVirtualMachinesVmIdStartPost(vmId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualMachineApi.startVmVirtualMachinesVmIdStartPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary Vnc Vm
     * @param {string} vmId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vncVmVirtualMachinesVmIdVncGet(
      vmId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vnc>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vncVmVirtualMachinesVmIdVncGet(vmId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VirtualMachineApi.vncVmVirtualMachinesVmIdVncGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * VirtualMachineApi - factory interface
 * @export
 */
export const VirtualMachineApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VirtualMachineApiFp(configuration)
  return {
    /**
     * It creates a virtual machine  Args:   data (schemas.CreateVirtualMachine): schemas.CreateVirtualMachine - this     is the data that will be passed to the function.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection. It means that the     function will be called with the VMCrud object.  Returns:   The return value is a dict.
     * @summary Create Vm
     * @param {VirtualMachineApiCreateVmVirtualMachinesCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVmVirtualMachinesCreatePost(
      requestParameters: VirtualMachineApiCreateVmVirtualMachinesCreatePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualMachineInfo> {
      return localVarFp
        .createVmVirtualMachinesCreatePost(requestParameters.createVirtualMachine, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a VM ID, uses the CRUD object to delete the VM, and returns the VM object  Args:   vm_id (str): str - the id of the VM to be deleted.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object that was deleted.
     * @summary Delete Vm
     * @param {VirtualMachineApiDeleteVmVirtualMachinesVmIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVmVirtualMachinesVmIdDelete(
      requestParameters: VirtualMachineApiDeleteVmVirtualMachinesVmIdDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .deleteVmVirtualMachinesVmIdDelete(requestParameters.vmId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a VM ID, and returns a VM object  Args:   vm_id (str): str - the id of the virtual machine to be edited.   data (str): schemas.VmEdit - edit data.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Edit Vm
     * @param {VirtualMachineApiEditVmVirtualMachinesVmIdEditPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editVmVirtualMachinesVmIdEditPost(
      requestParameters: VirtualMachineApiEditVmVirtualMachinesVmIdEditPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualMachineInfo> {
      return localVarFp
        .editVmVirtualMachinesVmIdEditPost(requestParameters.vmId, requestParameters.editVm, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a VM id as an argument, and returns a VM object  Args:   vm_id (Optional[str]): Optional[str] = Query(None, description=\"VM id\")   crud: Depends(VMCrud)  Returns:   Vm.
     * @summary Get Vm
     * @param {VirtualMachineApiGetVmVirtualMachinesVmIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVmVirtualMachinesVmIdGet(
      requestParameters: VirtualMachineApiGetVmVirtualMachinesVmIdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualMachineInfo> {
      return localVarFp
        .getVmVirtualMachinesVmIdGet(requestParameters.vmId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It gets all the vms from the database and returns them  Args:   crud: This is the dependency that we created in the previous section.  Returns:   A list of all vms.
     * @summary Get Vms
     * @param {VirtualMachineApiGetVmsVirtualMachinesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVmsVirtualMachinesGet(
      requestParameters: VirtualMachineApiGetVmsVirtualMachinesGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageVirtualMachineInfo> {
      return localVarFp
        .getVmsVirtualMachinesGet(requestParameters.page, requestParameters.size, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a VM ID, shut off the VM, and returns the VM  Args:   vm_id (str): str - the id of the VM to be turned off.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Shut Off Vm
     * @param {VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    shutOffVmVirtualMachinesVmIdShutOffPost(
      requestParameters: VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualMachineInfo> {
      return localVarFp
        .shutOffVmVirtualMachinesVmIdShutOffPost(requestParameters.vmId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It starts a VM  Args:   vm_id (str): str - the id of the VM to start.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
     * @summary Start Vm
     * @param {VirtualMachineApiStartVmVirtualMachinesVmIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startVmVirtualMachinesVmIdStartPost(
      requestParameters: VirtualMachineApiStartVmVirtualMachinesVmIdStartPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualMachineInfo> {
      return localVarFp
        .startVmVirtualMachinesVmIdStartPost(requestParameters.vmId, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Vnc Vm
     * @param {VirtualMachineApiVncVmVirtualMachinesVmIdVncGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vncVmVirtualMachinesVmIdVncGet(
      requestParameters: VirtualMachineApiVncVmVirtualMachinesVmIdVncGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Vnc> {
      return localVarFp
        .vncVmVirtualMachinesVmIdVncGet(requestParameters.vmId, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for createVmVirtualMachinesCreatePost operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiCreateVmVirtualMachinesCreatePostRequest
 */
export interface VirtualMachineApiCreateVmVirtualMachinesCreatePostRequest {
  /**
   *
   * @type {CreateVirtualMachine}
   * @memberof VirtualMachineApiCreateVmVirtualMachinesCreatePost
   */
  readonly createVirtualMachine: CreateVirtualMachine
}

/**
 * Request parameters for deleteVmVirtualMachinesVmIdDelete operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiDeleteVmVirtualMachinesVmIdDeleteRequest
 */
export interface VirtualMachineApiDeleteVmVirtualMachinesVmIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineApiDeleteVmVirtualMachinesVmIdDelete
   */
  readonly vmId: string
}

/**
 * Request parameters for editVmVirtualMachinesVmIdEditPost operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiEditVmVirtualMachinesVmIdEditPostRequest
 */
export interface VirtualMachineApiEditVmVirtualMachinesVmIdEditPostRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineApiEditVmVirtualMachinesVmIdEditPost
   */
  readonly vmId: string

  /**
   *
   * @type {EditVm}
   * @memberof VirtualMachineApiEditVmVirtualMachinesVmIdEditPost
   */
  readonly editVm: EditVm
}

/**
 * Request parameters for getVmVirtualMachinesVmIdGet operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiGetVmVirtualMachinesVmIdGetRequest
 */
export interface VirtualMachineApiGetVmVirtualMachinesVmIdGetRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineApiGetVmVirtualMachinesVmIdGet
   */
  readonly vmId: string
}

/**
 * Request parameters for getVmsVirtualMachinesGet operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiGetVmsVirtualMachinesGetRequest
 */
export interface VirtualMachineApiGetVmsVirtualMachinesGetRequest {
  /**
   *
   * @type {number}
   * @memberof VirtualMachineApiGetVmsVirtualMachinesGet
   */
  readonly page?: number

  /**
   *
   * @type {number}
   * @memberof VirtualMachineApiGetVmsVirtualMachinesGet
   */
  readonly size?: number
}

/**
 * Request parameters for shutOffVmVirtualMachinesVmIdShutOffPost operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPostRequest
 */
export interface VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPostRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPost
   */
  readonly vmId: string
}

/**
 * Request parameters for startVmVirtualMachinesVmIdStartPost operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiStartVmVirtualMachinesVmIdStartPostRequest
 */
export interface VirtualMachineApiStartVmVirtualMachinesVmIdStartPostRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineApiStartVmVirtualMachinesVmIdStartPost
   */
  readonly vmId: string
}

/**
 * Request parameters for vncVmVirtualMachinesVmIdVncGet operation in VirtualMachineApi.
 * @export
 * @interface VirtualMachineApiVncVmVirtualMachinesVmIdVncGetRequest
 */
export interface VirtualMachineApiVncVmVirtualMachinesVmIdVncGetRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualMachineApiVncVmVirtualMachinesVmIdVncGet
   */
  readonly vmId: string
}

/**
 * VirtualMachineApi - object-oriented interface
 * @export
 * @class VirtualMachineApi
 * @extends {BaseAPI}
 */
export class VirtualMachineApi extends BaseAPI {
  /**
   * It creates a virtual machine  Args:   data (schemas.CreateVirtualMachine): schemas.CreateVirtualMachine - this     is the data that will be passed to the function.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection. It means that the     function will be called with the VMCrud object.  Returns:   The return value is a dict.
   * @summary Create Vm
   * @param {VirtualMachineApiCreateVmVirtualMachinesCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public createVmVirtualMachinesCreatePost(
    requestParameters: VirtualMachineApiCreateVmVirtualMachinesCreatePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .createVmVirtualMachinesCreatePost(requestParameters.createVirtualMachine, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a VM ID, uses the CRUD object to delete the VM, and returns the VM object  Args:   vm_id (str): str - the id of the VM to be deleted.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object that was deleted.
   * @summary Delete Vm
   * @param {VirtualMachineApiDeleteVmVirtualMachinesVmIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public deleteVmVirtualMachinesVmIdDelete(
    requestParameters: VirtualMachineApiDeleteVmVirtualMachinesVmIdDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .deleteVmVirtualMachinesVmIdDelete(requestParameters.vmId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a VM ID, and returns a VM object  Args:   vm_id (str): str - the id of the virtual machine to be edited.   data (str): schemas.VmEdit - edit data.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
   * @summary Edit Vm
   * @param {VirtualMachineApiEditVmVirtualMachinesVmIdEditPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public editVmVirtualMachinesVmIdEditPost(
    requestParameters: VirtualMachineApiEditVmVirtualMachinesVmIdEditPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .editVmVirtualMachinesVmIdEditPost(requestParameters.vmId, requestParameters.editVm, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a VM id as an argument, and returns a VM object  Args:   vm_id (Optional[str]): Optional[str] = Query(None, description=\"VM id\")   crud: Depends(VMCrud)  Returns:   Vm.
   * @summary Get Vm
   * @param {VirtualMachineApiGetVmVirtualMachinesVmIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public getVmVirtualMachinesVmIdGet(
    requestParameters: VirtualMachineApiGetVmVirtualMachinesVmIdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .getVmVirtualMachinesVmIdGet(requestParameters.vmId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It gets all the vms from the database and returns them  Args:   crud: This is the dependency that we created in the previous section.  Returns:   A list of all vms.
   * @summary Get Vms
   * @param {VirtualMachineApiGetVmsVirtualMachinesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public getVmsVirtualMachinesGet(
    requestParameters: VirtualMachineApiGetVmsVirtualMachinesGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .getVmsVirtualMachinesGet(requestParameters.page, requestParameters.size, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a VM ID, shut off the VM, and returns the VM  Args:   vm_id (str): str - the id of the VM to be turned off.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
   * @summary Shut Off Vm
   * @param {VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public shutOffVmVirtualMachinesVmIdShutOffPost(
    requestParameters: VirtualMachineApiShutOffVmVirtualMachinesVmIdShutOffPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .shutOffVmVirtualMachinesVmIdShutOffPost(requestParameters.vmId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It starts a VM  Args:   vm_id (str): str - the id of the VM to start.   user_info: The dependency that check user was authorized   crud: Depends(VMCrud) - this is a dependency injection.  Returns:   The VM object.
   * @summary Start Vm
   * @param {VirtualMachineApiStartVmVirtualMachinesVmIdStartPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public startVmVirtualMachinesVmIdStartPost(
    requestParameters: VirtualMachineApiStartVmVirtualMachinesVmIdStartPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .startVmVirtualMachinesVmIdStartPost(requestParameters.vmId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Vnc Vm
   * @param {VirtualMachineApiVncVmVirtualMachinesVmIdVncGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualMachineApi
   */
  public vncVmVirtualMachinesVmIdVncGet(
    requestParameters: VirtualMachineApiVncVmVirtualMachinesVmIdVncGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualMachineApiFp(this.configuration)
      .vncVmVirtualMachinesVmIdVncGet(requestParameters.vmId, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VirtualNetworkApi - axios parameter creator
 * @export
 */
export const VirtualNetworkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Adds a port group to a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network to which the         port group will be added.     port_group (schemas.PortGroup): The port group data to be added.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network with the added         port group.  Responses:     200: Successful request. Returns the virtual network with the added port         group in the response model VirtualNetworkResponse.
     * @summary Add Port Group
     * @param {string} virtualNetworkId
     * @param {PortGroup} portGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost: async (
      virtualNetworkId: string,
      portGroup: PortGroup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists(
        'addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost',
        'virtualNetworkId',
        virtualNetworkId
      )
      // verify required parameter 'portGroup' is not null or undefined
      assertParamExists('addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost', 'portGroup', portGroup)
      const localVarPath = `/virtual_networks/{virtual_network_id}/add_port_group`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(portGroup, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Add Tag To Trunk Port Group
     * @param {string} virtualNetworkId
     * @param {string} portGroupName
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost: async (
      virtualNetworkId: string,
      portGroupName: string,
      tagId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists(
        'addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost',
        'virtualNetworkId',
        virtualNetworkId
      )
      // verify required parameter 'portGroupName' is not null or undefined
      assertParamExists(
        'addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost',
        'portGroupName',
        portGroupName
      )
      // verify required parameter 'tagId' is not null or undefined
      assertParamExists(
        'addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost',
        'tagId',
        tagId
      )
      const localVarPath = `/virtual_networks/{virtual_network_id}/{port_group_name/{trunk_id}/add_tag_id`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (portGroupName !== undefined) {
        localVarQueryParameter['port_group_name'] = portGroupName
      }

      if (tagId !== undefined) {
        localVarQueryParameter['tag_id'] = tagId
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new virtual network.  Args:     data (schemas.VirtualNetwork): Data representing the virtual network to         be created.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     schemas.VirtualNetwork: The schemas of newly created virtual network.  Responses:     200: Successful request. Returns the newly created virtual network in         the response model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Create Virtual Network
     * @param {VirtualNetwork} virtualNetwork
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualNetworkVirtualNetworksCreatePost: async (
      virtualNetwork: VirtualNetwork,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetwork' is not null or undefined
      assertParamExists('createVirtualNetworkVirtualNetworksCreatePost', 'virtualNetwork', virtualNetwork)
      const localVarPath = `/virtual_networks/create/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(virtualNetwork, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a port group from a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network from which the         port group will be deleted.     port_group_name (str): The name of the port group to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network after the port         group has been deleted.  Responses:     200: Successful request. Returns the virtual network after the port         group has been deleted.
     * @summary Delete Port Group
     * @param {string} virtualNetworkId
     * @param {string} portGroupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete: async (
      virtualNetworkId: string,
      portGroupName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists(
        'deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete',
        'virtualNetworkId',
        virtualNetworkId
      )
      // verify required parameter 'portGroupName' is not null or undefined
      assertParamExists(
        'deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete',
        'portGroupName',
        portGroupName
      )
      const localVarPath = `/virtual_networks/{virtual_network_id}/delete_port_group`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (portGroupName !== undefined) {
        localVarQueryParameter['port_group_name'] = portGroupName
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     JSONResponse: A message indicating the success of the delete operation.  Responses:     200: Successful request. Returns a message indicating the success of the         delete operation.
     * @summary Delete Virtual Network
     * @param {string} virtualNetworkId Virtual network id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete: async (
      virtualNetworkId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists(
        'deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete',
        'virtualNetworkId',
        virtualNetworkId
      )
      const localVarPath = `/virtual_networks/{virtual_network_id}`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided ID.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Get Virtual Network By Id
     * @param {string} virtualNetworkId Virtual network id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet: async (
      virtualNetworkId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists('getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet', 'virtualNetworkId', virtualNetworkId)
      const localVarPath = `/virtual_networks/{virtual_network_id}/`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves a virtual network by its name.  Args:     virtual_network_name (str): The name of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided name.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Get Virtual Network By Name
     * @param {string} virtualNetworkName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet: async (
      virtualNetworkName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkName' is not null or undefined
      assertParamExists(
        'getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet',
        'virtualNetworkName',
        virtualNetworkName
      )
      const localVarPath = `/virtual_networks/{virtual_network_name}`.replace(
        `{${'virtual_network_name'}}`,
        encodeURIComponent(String(virtualNetworkName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves a list of virtual networks.  Args:     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     List[schemas.VirtualNetwork]: A list of virtual networks.  Responses:     200: Successful request. Returns a list of virtual networks.     400: Request error. Returns an ErrorResponseModel.
     * @summary Get Virtual Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualNetworksVirtualNetworksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/virtual_networks/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Turns off a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned         off.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-off operation  Responses:     200: Successful request. Returns a message indicating the success of the         turn-off operation.
     * @summary Turn Off Virtual Network
     * @param {string} virtualNetworkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut: async (
      virtualNetworkId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists(
        'turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut',
        'virtualNetworkId',
        virtualNetworkId
      )
      const localVarPath = `/virtual_networks/{virtual_network_id}/turn_off`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Turns on a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned on.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-on operation.  Responses:     200: Successful request. Returns a message indicating the success of         the turn-on operation.
     * @summary Turn On Virtual Network
     * @param {string} virtualNetworkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut: async (
      virtualNetworkId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'virtualNetworkId' is not null or undefined
      assertParamExists(
        'turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut',
        'virtualNetworkId',
        virtualNetworkId
      )
      const localVarPath = `/virtual_networks/{virtual_network_id}/turn_on`.replace(
        `{${'virtual_network_id'}}`,
        encodeURIComponent(String(virtualNetworkId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VirtualNetworkApi - functional programming interface
 * @export
 */
export const VirtualNetworkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VirtualNetworkApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds a port group to a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network to which the         port group will be added.     port_group (schemas.PortGroup): The port group data to be added.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network with the added         port group.  Responses:     200: Successful request. Returns the virtual network with the added port         group in the response model VirtualNetworkResponse.
     * @summary Add Port Group
     * @param {string} virtualNetworkId
     * @param {PortGroup} portGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost(
      virtualNetworkId: string,
      portGroup: PortGroup,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualNetworkResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost(
          virtualNetworkId,
          portGroup,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @summary Add Tag To Trunk Port Group
     * @param {string} virtualNetworkId
     * @param {string} portGroupName
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost(
      virtualNetworkId: string,
      portGroupName: string,
      tagId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortGroup>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost(
          virtualNetworkId,
          portGroupName,
          tagId,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap[
          'VirtualNetworkApi.addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost'
        ]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Creates a new virtual network.  Args:     data (schemas.VirtualNetwork): Data representing the virtual network to         be created.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     schemas.VirtualNetwork: The schemas of newly created virtual network.  Responses:     200: Successful request. Returns the newly created virtual network in         the response model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Create Virtual Network
     * @param {VirtualNetwork} virtualNetwork
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createVirtualNetworkVirtualNetworksCreatePost(
      virtualNetwork: VirtualNetwork,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualNetworkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createVirtualNetworkVirtualNetworksCreatePost(
        virtualNetwork,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.createVirtualNetworkVirtualNetworksCreatePost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Deletes a port group from a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network from which the         port group will be deleted.     port_group_name (str): The name of the port group to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network after the port         group has been deleted.  Responses:     200: Successful request. Returns the virtual network after the port         group has been deleted.
     * @summary Delete Port Group
     * @param {string} virtualNetworkId
     * @param {string} portGroupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete(
      virtualNetworkId: string,
      portGroupName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete(
          virtualNetworkId,
          portGroupName,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Deletes a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     JSONResponse: A message indicating the success of the delete operation.  Responses:     200: Successful request. Returns a message indicating the success of the         delete operation.
     * @summary Delete Virtual Network
     * @param {string} virtualNetworkId Virtual network id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete(
      virtualNetworkId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete(
          virtualNetworkId,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieves a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided ID.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Get Virtual Network By Id
     * @param {string} virtualNetworkId Virtual network id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet(
      virtualNetworkId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualNetworkResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet(
        virtualNetworkId,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieves a virtual network by its name.  Args:     virtual_network_name (str): The name of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided name.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Get Virtual Network By Name
     * @param {string} virtualNetworkName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet(
      virtualNetworkName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualNetworkResponse>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet(
          virtualNetworkName,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Retrieves a list of virtual networks.  Args:     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     List[schemas.VirtualNetwork]: A list of virtual networks.  Responses:     200: Successful request. Returns a list of virtual networks.     400: Request error. Returns an ErrorResponseModel.
     * @summary Get Virtual Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVirtualNetworksVirtualNetworksGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOfVirtualNetworksResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVirtualNetworksVirtualNetworksGet(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.getVirtualNetworksVirtualNetworksGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Turns off a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned         off.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-off operation  Responses:     200: Successful request. Returns a message indicating the success of the         turn-off operation.
     * @summary Turn Off Virtual Network
     * @param {string} virtualNetworkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut(
      virtualNetworkId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut(
          virtualNetworkId,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Turns on a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned on.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-on operation.  Responses:     200: Successful request. Returns a message indicating the success of         the turn-on operation.
     * @summary Turn On Virtual Network
     * @param {string} virtualNetworkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut(
      virtualNetworkId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut(
          virtualNetworkId,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['VirtualNetworkApi.turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * VirtualNetworkApi - factory interface
 * @export
 */
export const VirtualNetworkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VirtualNetworkApiFp(configuration)
  return {
    /**
     * Adds a port group to a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network to which the         port group will be added.     port_group (schemas.PortGroup): The port group data to be added.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network with the added         port group.  Responses:     200: Successful request. Returns the virtual network with the added port         group in the response model VirtualNetworkResponse.
     * @summary Add Port Group
     * @param {VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost(
      requestParameters: VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualNetworkResponse> {
      return localVarFp
        .addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost(
          requestParameters.virtualNetworkId,
          requestParameters.portGroup,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add Tag To Trunk Port Group
     * @param {VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost(
      requestParameters: VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PortGroup> {
      return localVarFp
        .addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost(
          requestParameters.virtualNetworkId,
          requestParameters.portGroupName,
          requestParameters.tagId,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Creates a new virtual network.  Args:     data (schemas.VirtualNetwork): Data representing the virtual network to         be created.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     schemas.VirtualNetwork: The schemas of newly created virtual network.  Responses:     200: Successful request. Returns the newly created virtual network in         the response model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Create Virtual Network
     * @param {VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVirtualNetworkVirtualNetworksCreatePost(
      requestParameters: VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualNetworkResponse> {
      return localVarFp
        .createVirtualNetworkVirtualNetworksCreatePost(requestParameters.virtualNetwork, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes a port group from a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network from which the         port group will be deleted.     port_group_name (str): The name of the port group to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network after the port         group has been deleted.  Responses:     200: Successful request. Returns the virtual network after the port         group has been deleted.
     * @summary Delete Port Group
     * @param {VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete(
      requestParameters: VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete(
          requestParameters.virtualNetworkId,
          requestParameters.portGroupName,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * Deletes a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     JSONResponse: A message indicating the success of the delete operation.  Responses:     200: Successful request. Returns a message indicating the success of the         delete operation.
     * @summary Delete Virtual Network
     * @param {VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete(
      requestParameters: VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete(requestParameters.virtualNetworkId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieves a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided ID.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Get Virtual Network By Id
     * @param {VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet(
      requestParameters: VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualNetworkResponse> {
      return localVarFp
        .getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet(requestParameters.virtualNetworkId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieves a virtual network by its name.  Args:     virtual_network_name (str): The name of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided name.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
     * @summary Get Virtual Network By Name
     * @param {VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet(
      requestParameters: VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VirtualNetworkResponse> {
      return localVarFp
        .getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet(requestParameters.virtualNetworkName, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Retrieves a list of virtual networks.  Args:     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     List[schemas.VirtualNetwork]: A list of virtual networks.  Responses:     200: Successful request. Returns a list of virtual networks.     400: Request error. Returns an ErrorResponseModel.
     * @summary Get Virtual Networks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVirtualNetworksVirtualNetworksGet(options?: RawAxiosRequestConfig): AxiosPromise<ListOfVirtualNetworksResponse> {
      return localVarFp.getVirtualNetworksVirtualNetworksGet(options).then(request => request(axios, basePath))
    },
    /**
     * Turns off a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned         off.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-off operation  Responses:     200: Successful request. Returns a message indicating the success of the         turn-off operation.
     * @summary Turn Off Virtual Network
     * @param {VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut(
      requestParameters: VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPutRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut(requestParameters.virtualNetworkId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Turns on a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned on.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-on operation.  Responses:     200: Successful request. Returns a message indicating the success of         the turn-on operation.
     * @summary Turn On Virtual Network
     * @param {VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut(
      requestParameters: VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPutRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut(requestParameters.virtualNetworkId, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPostRequest
 */
export interface VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPostRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost
   */
  readonly virtualNetworkId: string

  /**
   *
   * @type {PortGroup}
   * @memberof VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost
   */
  readonly portGroup: PortGroup
}

/**
 * Request parameters for addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPostRequest
 */
export interface VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPostRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost
   */
  readonly virtualNetworkId: string

  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost
   */
  readonly portGroupName: string

  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost
   */
  readonly tagId: string
}

/**
 * Request parameters for createVirtualNetworkVirtualNetworksCreatePost operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePostRequest
 */
export interface VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePostRequest {
  /**
   *
   * @type {VirtualNetwork}
   * @memberof VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePost
   */
  readonly virtualNetwork: VirtualNetwork
}

/**
 * Request parameters for deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDeleteRequest
 */
export interface VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete
   */
  readonly virtualNetworkId: string

  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete
   */
  readonly portGroupName: string
}

/**
 * Request parameters for deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDeleteRequest
 */
export interface VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDeleteRequest {
  /**
   * Virtual network id
   * @type {string}
   * @memberof VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete
   */
  readonly virtualNetworkId: string
}

/**
 * Request parameters for getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGetRequest
 */
export interface VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGetRequest {
  /**
   * Virtual network id
   * @type {string}
   * @memberof VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet
   */
  readonly virtualNetworkId: string
}

/**
 * Request parameters for getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGetRequest
 */
export interface VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGetRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet
   */
  readonly virtualNetworkName: string
}

/**
 * Request parameters for turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPutRequest
 */
export interface VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPutRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut
   */
  readonly virtualNetworkId: string
}

/**
 * Request parameters for turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut operation in VirtualNetworkApi.
 * @export
 * @interface VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPutRequest
 */
export interface VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPutRequest {
  /**
   *
   * @type {string}
   * @memberof VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut
   */
  readonly virtualNetworkId: string
}

/**
 * VirtualNetworkApi - object-oriented interface
 * @export
 * @class VirtualNetworkApi
 * @extends {BaseAPI}
 */
export class VirtualNetworkApi extends BaseAPI {
  /**
   * Adds a port group to a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network to which the         port group will be added.     port_group (schemas.PortGroup): The port group data to be added.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network with the added         port group.  Responses:     200: Successful request. Returns the virtual network with the added port         group in the response model VirtualNetworkResponse.
   * @summary Add Port Group
   * @param {VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost(
    requestParameters: VirtualNetworkApiAddPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .addPortGroupVirtualNetworksVirtualNetworkIdAddPortGroupPost(
        requestParameters.virtualNetworkId,
        requestParameters.portGroup,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add Tag To Trunk Port Group
   * @param {VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost(
    requestParameters: VirtualNetworkApiAddTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .addTagToTrunkPortGroupVirtualNetworksVirtualNetworkIdPortGroupNameTrunkIdAddTagIdPost(
        requestParameters.virtualNetworkId,
        requestParameters.portGroupName,
        requestParameters.tagId,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Creates a new virtual network.  Args:     data (schemas.VirtualNetwork): Data representing the virtual network to         be created.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     schemas.VirtualNetwork: The schemas of newly created virtual network.  Responses:     200: Successful request. Returns the newly created virtual network in         the response model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
   * @summary Create Virtual Network
   * @param {VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public createVirtualNetworkVirtualNetworksCreatePost(
    requestParameters: VirtualNetworkApiCreateVirtualNetworkVirtualNetworksCreatePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .createVirtualNetworkVirtualNetworksCreatePost(requestParameters.virtualNetwork, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes a port group from a virtual network.  Args:     virtual_network_id (str): The ID of the virtual network from which the         port group will be deleted.     port_group_name (str): The name of the port group to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User info  Returns:     schemas.VirtualNetwork: The schema of virtual network after the port         group has been deleted.  Responses:     200: Successful request. Returns the virtual network after the port         group has been deleted.
   * @summary Delete Port Group
   * @param {VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete(
    requestParameters: VirtualNetworkApiDeletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .deletePortGroupVirtualNetworksVirtualNetworkIdDeletePortGroupDelete(
        requestParameters.virtualNetworkId,
        requestParameters.portGroupName,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Deletes a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be deleted.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.     user_info: User Info  Returns:     JSONResponse: A message indicating the success of the delete operation.  Responses:     200: Successful request. Returns a message indicating the success of the         delete operation.
   * @summary Delete Virtual Network
   * @param {VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete(
    requestParameters: VirtualNetworkApiDeleteVirtualNetworkVirtualNetworksVirtualNetworkIdDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .deleteVirtualNetworkVirtualNetworksVirtualNetworkIdDelete(requestParameters.virtualNetworkId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieves a virtual network by its ID.  Args:     virtual_network_id (str): The ID of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided ID.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
   * @summary Get Virtual Network By Id
   * @param {VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet(
    requestParameters: VirtualNetworkApiGetVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .getVirtualNetworkByIdVirtualNetworksVirtualNetworkIdGet(requestParameters.virtualNetworkId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieves a virtual network by its name.  Args:     virtual_network_name (str): The name of the virtual network.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     schemas.VirtualNetwork: The virtual network schema corresponding to the         provided name.  Responses:     200: Successful request. Returns the virtual network in the response         model VirtualNetworkResponse.     400: Request error. Returns an ErrorResponseModel in case of an error.
   * @summary Get Virtual Network By Name
   * @param {VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet(
    requestParameters: VirtualNetworkApiGetVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .getVirtualNetworkByNameVirtualNetworksVirtualNetworkNameGet(requestParameters.virtualNetworkName, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Retrieves a list of virtual networks.  Args:     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     List[schemas.VirtualNetwork]: A list of virtual networks.  Responses:     200: Successful request. Returns a list of virtual networks.     400: Request error. Returns an ErrorResponseModel.
   * @summary Get Virtual Networks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public getVirtualNetworksVirtualNetworksGet(options?: RawAxiosRequestConfig) {
    return VirtualNetworkApiFp(this.configuration)
      .getVirtualNetworksVirtualNetworksGet(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Turns off a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned         off.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection.         It means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-off operation  Responses:     200: Successful request. Returns a message indicating the success of the         turn-off operation.
   * @summary Turn Off Virtual Network
   * @param {VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut(
    requestParameters: VirtualNetworkApiTurnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPutRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .turnOffVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOffPut(requestParameters.virtualNetworkId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Turns on a virtual network identified by its ID.  Args:     virtual_network_id (str): The ID of the virtual network to be turned on.     crud: Depends(VirtualNetworkCrud) - This is a dependency injection. It         means that the function will receive an instance of the         VirtualNetworkCrud class.  Returns:     JSONResponse: A message indicating the success of the turn-on operation.  Responses:     200: Successful request. Returns a message indicating the success of         the turn-on operation.
   * @summary Turn On Virtual Network
   * @param {VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VirtualNetworkApi
   */
  public turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut(
    requestParameters: VirtualNetworkApiTurnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPutRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VirtualNetworkApiFp(this.configuration)
      .turnOnVirtualNetworkVirtualNetworksVirtualNetworkIdTurnOnPut(requestParameters.virtualNetworkId, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VolumeApi - axios parameter creator
 * @export
 */
export const VolumeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * It takes a volume_id and a data object, and then it calls the attach_volume method on the scheduler manager  Args:     volume_id (str): The ID of the volume to be attached.     data (schemas.AttachVolume): schemas.AttachVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
     * @summary Attach Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {OpenvairModulesVolumeEntrypointsSchemasAttachVolume} openvairModulesVolumeEntrypointsSchemasAttachVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachVolumeVolumesVolumeIdAttachPost: async (
      volumeId: string,
      openvairModulesVolumeEntrypointsSchemasAttachVolume: OpenvairModulesVolumeEntrypointsSchemasAttachVolume,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'volumeId' is not null or undefined
      assertParamExists('attachVolumeVolumesVolumeIdAttachPost', 'volumeId', volumeId)
      // verify required parameter 'openvairModulesVolumeEntrypointsSchemasAttachVolume' is not null or undefined
      assertParamExists(
        'attachVolumeVolumesVolumeIdAttachPost',
        'openvairModulesVolumeEntrypointsSchemasAttachVolume',
        openvairModulesVolumeEntrypointsSchemasAttachVolume
      )
      const localVarPath = `/volumes/{volume_id}/attach/`.replace(
        `{${'volume_id'}}`,
        encodeURIComponent(String(volumeId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(
        openvairModulesVolumeEntrypointsSchemasAttachVolume,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     data (schemas.CreateVolume): schemas.CreateVolume - this is the data         that will be passed to the function.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Create Volume
     * @param {CreateVolume} createVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVolumeVolumesCreatePost: async (
      createVolume: CreateVolume,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createVolume' is not null or undefined
      assertParamExists('createVolumeVolumesCreatePost', 'createVolume', createVolume)
      const localVarPath = `/volumes/create/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(createVolume, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     volume_id: str     user_info: The dependency that check user was authorized      crud: This is the dependency that we created in the previous section.  Returns:     result
     * @summary Delete Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVolumeVolumesVolumeIdDelete: async (
      volumeId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'volumeId' is not null or undefined
      assertParamExists('deleteVolumeVolumesVolumeIdDelete', 'volumeId', volumeId)
      const localVarPath = `/volumes/{volume_id}/`.replace(`{${'volume_id'}}`, encodeURIComponent(String(volumeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It calls the scheduler service to detach a volume from a node  Args:     volume_id (str): The ID of the volume to be detached.     detach_info (str): The ID of the vm.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The volume object.
     * @summary Detach Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {DetachVolume} detachVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachVolumeVolumesVolumeIdDetachDelete: async (
      volumeId: string,
      detachVolume: DetachVolume,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'volumeId' is not null or undefined
      assertParamExists('detachVolumeVolumesVolumeIdDetachDelete', 'volumeId', volumeId)
      // verify required parameter 'detachVolume' is not null or undefined
      assertParamExists('detachVolumeVolumesVolumeIdDetachDelete', 'detachVolume', detachVolume)
      const localVarPath = `/volumes/{volume_id}/detach/`.replace(
        `{${'volume_id'}}`,
        encodeURIComponent(String(volumeId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(detachVolume, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It takes a volume_id and a data object, and then calls the scheduler to edit the volume  Args:     volume_id (str): str - the volume id     data (schemas.EditVolume): schemas.EditVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
     * @summary Edit Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {EditVolume} editVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editVolumeVolumesVolumeIdEditPut: async (
      volumeId: string,
      editVolume: EditVolume,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'volumeId' is not null or undefined
      assertParamExists('editVolumeVolumesVolumeIdEditPut', 'volumeId', volumeId)
      // verify required parameter 'editVolume' is not null or undefined
      assertParamExists('editVolumeVolumesVolumeIdEditPut', 'editVolume', editVolume)
      const localVarPath = `/volumes/{volume_id}/edit/`.replace(
        `{${'volume_id'}}`,
        encodeURIComponent(String(volumeId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(editVolume, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It receives a volume_id and a data object, and then it calls the extend_volume method of the SchedulerManager class  Args:     volume_id (str): str - the volume id     data (schemas.ExtendVolume): This is the data that is passed to the API.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Extend Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {ExtendVolume} extendVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extendVolumeVolumesVolumeIdExtendPost: async (
      volumeId: string,
      extendVolume: ExtendVolume,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'volumeId' is not null or undefined
      assertParamExists('extendVolumeVolumesVolumeIdExtendPost', 'volumeId', volumeId)
      // verify required parameter 'extendVolume' is not null or undefined
      assertParamExists('extendVolumeVolumesVolumeIdExtendPost', 'extendVolume', extendVolume)
      const localVarPath = `/volumes/{volume_id}/extend/`.replace(
        `{${'volume_id'}}`,
        encodeURIComponent(String(volumeId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(extendVolume, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * There is a function that takes a volume_id as an argument, and returns a serialized volume object. If volume_id doesn\'t come the function will return all serialized volume objects.  Args:     volume_id (Optional[str]): Optional[str] =     Query(None, description=\"Volume id\")     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Get Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumeVolumesVolumeIdGet: async (
      volumeId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'volumeId' is not null or undefined
      assertParamExists('getVolumeVolumesVolumeIdGet', 'volumeId', volumeId)
      const localVarPath = `/volumes/{volume_id}/`.replace(`{${'volume_id'}}`, encodeURIComponent(String(volumeId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * It gets all volumes from the database  Args:     storage_id: Storage id     free_volumes: parameter if True will return volume without attachments     crud: This is the dependency that we created in the previous section.  Returns:     A list of volumes.
     * @summary Get Volumes
     * @param {string} [storageId] Storage id (UUID4)
     * @param {boolean} [freeVolumes] Flag on getting volumes without attachments.
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumesVolumesGet: async (
      storageId?: string,
      freeVolumes?: boolean,
      page?: number,
      size?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/volumes/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, 'OAuth2PasswordBearer', [], configuration)

      if (storageId !== undefined) {
        localVarQueryParameter['storage_id'] = storageId
      }

      if (freeVolumes !== undefined) {
        localVarQueryParameter['free_volumes'] = freeVolumes
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VolumeApi - functional programming interface
 * @export
 */
export const VolumeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VolumeApiAxiosParamCreator(configuration)
  return {
    /**
     * It takes a volume_id and a data object, and then it calls the attach_volume method on the scheduler manager  Args:     volume_id (str): The ID of the volume to be attached.     data (schemas.AttachVolume): schemas.AttachVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
     * @summary Attach Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {OpenvairModulesVolumeEntrypointsSchemasAttachVolume} openvairModulesVolumeEntrypointsSchemasAttachVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attachVolumeVolumesVolumeIdAttachPost(
      volumeId: string,
      openvairModulesVolumeEntrypointsSchemasAttachVolume: OpenvairModulesVolumeEntrypointsSchemasAttachVolume,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachVolumeInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.attachVolumeVolumesVolumeIdAttachPost(
        volumeId,
        openvairModulesVolumeEntrypointsSchemasAttachVolume,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.attachVolumeVolumesVolumeIdAttachPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     data (schemas.CreateVolume): schemas.CreateVolume - this is the data         that will be passed to the function.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Create Volume
     * @param {CreateVolume} createVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createVolumeVolumesCreatePost(
      createVolume: CreateVolume,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createVolumeVolumesCreatePost(createVolume, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.createVolumeVolumesCreatePost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     volume_id: str     user_info: The dependency that check user was authorized      crud: This is the dependency that we created in the previous section.  Returns:     result
     * @summary Delete Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVolumeVolumesVolumeIdDelete(
      volumeId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVolumeVolumesVolumeIdDelete(volumeId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.deleteVolumeVolumesVolumeIdDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It calls the scheduler service to detach a volume from a node  Args:     volume_id (str): The ID of the volume to be detached.     detach_info (str): The ID of the vm.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The volume object.
     * @summary Detach Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {DetachVolume} detachVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async detachVolumeVolumesVolumeIdDetachDelete(
      volumeId: string,
      detachVolume: DetachVolume,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.detachVolumeVolumesVolumeIdDetachDelete(
        volumeId,
        detachVolume,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.detachVolumeVolumesVolumeIdDetachDelete']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It takes a volume_id and a data object, and then calls the scheduler to edit the volume  Args:     volume_id (str): str - the volume id     data (schemas.EditVolume): schemas.EditVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
     * @summary Edit Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {EditVolume} editVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async editVolumeVolumesVolumeIdEditPut(
      volumeId: string,
      editVolume: EditVolume,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.editVolumeVolumesVolumeIdEditPut(
        volumeId,
        editVolume,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.editVolumeVolumesVolumeIdEditPut']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It receives a volume_id and a data object, and then it calls the extend_volume method of the SchedulerManager class  Args:     volume_id (str): str - the volume id     data (schemas.ExtendVolume): This is the data that is passed to the API.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Extend Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {ExtendVolume} extendVolume
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async extendVolumeVolumesVolumeIdExtendPost(
      volumeId: string,
      extendVolume: ExtendVolume,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.extendVolumeVolumesVolumeIdExtendPost(
        volumeId,
        extendVolume,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.extendVolumeVolumesVolumeIdExtendPost']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * There is a function that takes a volume_id as an argument, and returns a serialized volume object. If volume_id doesn\'t come the function will return all serialized volume objects.  Args:     volume_id (Optional[str]): Optional[str] =     Query(None, description=\"Volume id\")     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Get Volume
     * @param {string} volumeId Volume id (UUID4)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVolumeVolumesVolumeIdGet(
      volumeId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumeVolumesVolumeIdGet(volumeId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.getVolumeVolumesVolumeIdGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * It gets all volumes from the database  Args:     storage_id: Storage id     free_volumes: parameter if True will return volume without attachments     crud: This is the dependency that we created in the previous section.  Returns:     A list of volumes.
     * @summary Get Volumes
     * @param {string} [storageId] Storage id (UUID4)
     * @param {boolean} [freeVolumes] Flag on getting volumes without attachments.
     * @param {number} [page]
     * @param {number} [size]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVolumesVolumesGet(
      storageId?: string,
      freeVolumes?: boolean,
      page?: number,
      size?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageVolume>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVolumesVolumesGet(
        storageId,
        freeVolumes,
        page,
        size,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath = operationServerMap['VolumeApi.getVolumesVolumesGet']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * VolumeApi - factory interface
 * @export
 */
export const VolumeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = VolumeApiFp(configuration)
  return {
    /**
     * It takes a volume_id and a data object, and then it calls the attach_volume method on the scheduler manager  Args:     volume_id (str): The ID of the volume to be attached.     data (schemas.AttachVolume): schemas.AttachVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
     * @summary Attach Volume
     * @param {VolumeApiAttachVolumeVolumesVolumeIdAttachPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attachVolumeVolumesVolumeIdAttachPost(
      requestParameters: VolumeApiAttachVolumeVolumesVolumeIdAttachPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<AttachVolumeInfo> {
      return localVarFp
        .attachVolumeVolumesVolumeIdAttachPost(
          requestParameters.volumeId,
          requestParameters.openvairModulesVolumeEntrypointsSchemasAttachVolume,
          options
        )
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     data (schemas.CreateVolume): schemas.CreateVolume - this is the data         that will be passed to the function.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Create Volume
     * @param {VolumeApiCreateVolumeVolumesCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVolumeVolumesCreatePost(
      requestParameters: VolumeApiCreateVolumeVolumesCreatePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Volume> {
      return localVarFp
        .createVolumeVolumesCreatePost(requestParameters.createVolume, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     volume_id: str     user_info: The dependency that check user was authorized      crud: This is the dependency that we created in the previous section.  Returns:     result
     * @summary Delete Volume
     * @param {VolumeApiDeleteVolumeVolumesVolumeIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVolumeVolumesVolumeIdDelete(
      requestParameters: VolumeApiDeleteVolumeVolumesVolumeIdDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Volume> {
      return localVarFp
        .deleteVolumeVolumesVolumeIdDelete(requestParameters.volumeId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It calls the scheduler service to detach a volume from a node  Args:     volume_id (str): The ID of the volume to be detached.     detach_info (str): The ID of the vm.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The volume object.
     * @summary Detach Volume
     * @param {VolumeApiDetachVolumeVolumesVolumeIdDetachDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    detachVolumeVolumesVolumeIdDetachDelete(
      requestParameters: VolumeApiDetachVolumeVolumesVolumeIdDetachDeleteRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Volume> {
      return localVarFp
        .detachVolumeVolumesVolumeIdDetachDelete(requestParameters.volumeId, requestParameters.detachVolume, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It takes a volume_id and a data object, and then calls the scheduler to edit the volume  Args:     volume_id (str): str - the volume id     data (schemas.EditVolume): schemas.EditVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
     * @summary Edit Volume
     * @param {VolumeApiEditVolumeVolumesVolumeIdEditPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editVolumeVolumesVolumeIdEditPut(
      requestParameters: VolumeApiEditVolumeVolumesVolumeIdEditPutRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Volume> {
      return localVarFp
        .editVolumeVolumesVolumeIdEditPut(requestParameters.volumeId, requestParameters.editVolume, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It receives a volume_id and a data object, and then it calls the extend_volume method of the SchedulerManager class  Args:     volume_id (str): str - the volume id     data (schemas.ExtendVolume): This is the data that is passed to the API.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Extend Volume
     * @param {VolumeApiExtendVolumeVolumesVolumeIdExtendPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    extendVolumeVolumesVolumeIdExtendPost(
      requestParameters: VolumeApiExtendVolumeVolumesVolumeIdExtendPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Volume> {
      return localVarFp
        .extendVolumeVolumesVolumeIdExtendPost(requestParameters.volumeId, requestParameters.extendVolume, options)
        .then(request => request(axios, basePath))
    },
    /**
     * There is a function that takes a volume_id as an argument, and returns a serialized volume object. If volume_id doesn\'t come the function will return all serialized volume objects.  Args:     volume_id (Optional[str]): Optional[str] =     Query(None, description=\"Volume id\")     crud: This is the dependency that we created in the previous section.  Returns:     volume
     * @summary Get Volume
     * @param {VolumeApiGetVolumeVolumesVolumeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumeVolumesVolumeIdGet(
      requestParameters: VolumeApiGetVolumeVolumesVolumeIdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Volume> {
      return localVarFp
        .getVolumeVolumesVolumeIdGet(requestParameters.volumeId, options)
        .then(request => request(axios, basePath))
    },
    /**
     * It gets all volumes from the database  Args:     storage_id: Storage id     free_volumes: parameter if True will return volume without attachments     crud: This is the dependency that we created in the previous section.  Returns:     A list of volumes.
     * @summary Get Volumes
     * @param {VolumeApiGetVolumesVolumesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVolumesVolumesGet(
      requestParameters: VolumeApiGetVolumesVolumesGetRequest = {},
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageVolume> {
      return localVarFp
        .getVolumesVolumesGet(
          requestParameters.storageId,
          requestParameters.freeVolumes,
          requestParameters.page,
          requestParameters.size,
          options
        )
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for attachVolumeVolumesVolumeIdAttachPost operation in VolumeApi.
 * @export
 * @interface VolumeApiAttachVolumeVolumesVolumeIdAttachPostRequest
 */
export interface VolumeApiAttachVolumeVolumesVolumeIdAttachPostRequest {
  /**
   * Volume id (UUID4)
   * @type {string}
   * @memberof VolumeApiAttachVolumeVolumesVolumeIdAttachPost
   */
  readonly volumeId: string

  /**
   *
   * @type {OpenvairModulesVolumeEntrypointsSchemasAttachVolume}
   * @memberof VolumeApiAttachVolumeVolumesVolumeIdAttachPost
   */
  readonly openvairModulesVolumeEntrypointsSchemasAttachVolume: OpenvairModulesVolumeEntrypointsSchemasAttachVolume
}

/**
 * Request parameters for createVolumeVolumesCreatePost operation in VolumeApi.
 * @export
 * @interface VolumeApiCreateVolumeVolumesCreatePostRequest
 */
export interface VolumeApiCreateVolumeVolumesCreatePostRequest {
  /**
   *
   * @type {CreateVolume}
   * @memberof VolumeApiCreateVolumeVolumesCreatePost
   */
  readonly createVolume: CreateVolume
}

/**
 * Request parameters for deleteVolumeVolumesVolumeIdDelete operation in VolumeApi.
 * @export
 * @interface VolumeApiDeleteVolumeVolumesVolumeIdDeleteRequest
 */
export interface VolumeApiDeleteVolumeVolumesVolumeIdDeleteRequest {
  /**
   * Volume id (UUID4)
   * @type {string}
   * @memberof VolumeApiDeleteVolumeVolumesVolumeIdDelete
   */
  readonly volumeId: string
}

/**
 * Request parameters for detachVolumeVolumesVolumeIdDetachDelete operation in VolumeApi.
 * @export
 * @interface VolumeApiDetachVolumeVolumesVolumeIdDetachDeleteRequest
 */
export interface VolumeApiDetachVolumeVolumesVolumeIdDetachDeleteRequest {
  /**
   * Volume id (UUID4)
   * @type {string}
   * @memberof VolumeApiDetachVolumeVolumesVolumeIdDetachDelete
   */
  readonly volumeId: string

  /**
   *
   * @type {DetachVolume}
   * @memberof VolumeApiDetachVolumeVolumesVolumeIdDetachDelete
   */
  readonly detachVolume: DetachVolume
}

/**
 * Request parameters for editVolumeVolumesVolumeIdEditPut operation in VolumeApi.
 * @export
 * @interface VolumeApiEditVolumeVolumesVolumeIdEditPutRequest
 */
export interface VolumeApiEditVolumeVolumesVolumeIdEditPutRequest {
  /**
   * Volume id (UUID4)
   * @type {string}
   * @memberof VolumeApiEditVolumeVolumesVolumeIdEditPut
   */
  readonly volumeId: string

  /**
   *
   * @type {EditVolume}
   * @memberof VolumeApiEditVolumeVolumesVolumeIdEditPut
   */
  readonly editVolume: EditVolume
}

/**
 * Request parameters for extendVolumeVolumesVolumeIdExtendPost operation in VolumeApi.
 * @export
 * @interface VolumeApiExtendVolumeVolumesVolumeIdExtendPostRequest
 */
export interface VolumeApiExtendVolumeVolumesVolumeIdExtendPostRequest {
  /**
   * Volume id (UUID4)
   * @type {string}
   * @memberof VolumeApiExtendVolumeVolumesVolumeIdExtendPost
   */
  readonly volumeId: string

  /**
   *
   * @type {ExtendVolume}
   * @memberof VolumeApiExtendVolumeVolumesVolumeIdExtendPost
   */
  readonly extendVolume: ExtendVolume
}

/**
 * Request parameters for getVolumeVolumesVolumeIdGet operation in VolumeApi.
 * @export
 * @interface VolumeApiGetVolumeVolumesVolumeIdGetRequest
 */
export interface VolumeApiGetVolumeVolumesVolumeIdGetRequest {
  /**
   * Volume id (UUID4)
   * @type {string}
   * @memberof VolumeApiGetVolumeVolumesVolumeIdGet
   */
  readonly volumeId: string
}

/**
 * Request parameters for getVolumesVolumesGet operation in VolumeApi.
 * @export
 * @interface VolumeApiGetVolumesVolumesGetRequest
 */
export interface VolumeApiGetVolumesVolumesGetRequest {
  /**
   * Storage id (UUID4)
   * @type {string}
   * @memberof VolumeApiGetVolumesVolumesGet
   */
  readonly storageId?: string

  /**
   * Flag on getting volumes without attachments.
   * @type {boolean}
   * @memberof VolumeApiGetVolumesVolumesGet
   */
  readonly freeVolumes?: boolean

  /**
   *
   * @type {number}
   * @memberof VolumeApiGetVolumesVolumesGet
   */
  readonly page?: number

  /**
   *
   * @type {number}
   * @memberof VolumeApiGetVolumesVolumesGet
   */
  readonly size?: number
}

/**
 * VolumeApi - object-oriented interface
 * @export
 * @class VolumeApi
 * @extends {BaseAPI}
 */
export class VolumeApi extends BaseAPI {
  /**
   * It takes a volume_id and a data object, and then it calls the attach_volume method on the scheduler manager  Args:     volume_id (str): The ID of the volume to be attached.     data (schemas.AttachVolume): schemas.AttachVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
   * @summary Attach Volume
   * @param {VolumeApiAttachVolumeVolumesVolumeIdAttachPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public attachVolumeVolumesVolumeIdAttachPost(
    requestParameters: VolumeApiAttachVolumeVolumesVolumeIdAttachPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .attachVolumeVolumesVolumeIdAttachPost(
        requestParameters.volumeId,
        requestParameters.openvairModulesVolumeEntrypointsSchemasAttachVolume,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     data (schemas.CreateVolume): schemas.CreateVolume - this is the data         that will be passed to the function.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
   * @summary Create Volume
   * @param {VolumeApiCreateVolumeVolumesCreatePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public createVolumeVolumesCreatePost(
    requestParameters: VolumeApiCreateVolumeVolumesCreatePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .createVolumeVolumesCreatePost(requestParameters.createVolume, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a request from the client, sends it to the scheduler, and returns the response from the scheduler to the client  Args:     volume_id: str     user_info: The dependency that check user was authorized      crud: This is the dependency that we created in the previous section.  Returns:     result
   * @summary Delete Volume
   * @param {VolumeApiDeleteVolumeVolumesVolumeIdDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public deleteVolumeVolumesVolumeIdDelete(
    requestParameters: VolumeApiDeleteVolumeVolumesVolumeIdDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .deleteVolumeVolumesVolumeIdDelete(requestParameters.volumeId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It calls the scheduler service to detach a volume from a node  Args:     volume_id (str): The ID of the volume to be detached.     detach_info (str): The ID of the vm.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The volume object.
   * @summary Detach Volume
   * @param {VolumeApiDetachVolumeVolumesVolumeIdDetachDeleteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public detachVolumeVolumesVolumeIdDetachDelete(
    requestParameters: VolumeApiDetachVolumeVolumesVolumeIdDetachDeleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .detachVolumeVolumesVolumeIdDetachDelete(requestParameters.volumeId, requestParameters.detachVolume, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It takes a volume_id and a data object, and then calls the scheduler to edit the volume  Args:     volume_id (str): str - the volume id     data (schemas.EditVolume): schemas.EditVolume     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     The return value is a JSONResponse object.
   * @summary Edit Volume
   * @param {VolumeApiEditVolumeVolumesVolumeIdEditPutRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public editVolumeVolumesVolumeIdEditPut(
    requestParameters: VolumeApiEditVolumeVolumesVolumeIdEditPutRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .editVolumeVolumesVolumeIdEditPut(requestParameters.volumeId, requestParameters.editVolume, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It receives a volume_id and a data object, and then it calls the extend_volume method of the SchedulerManager class  Args:     volume_id (str): str - the volume id     data (schemas.ExtendVolume): This is the data that is passed to the API.     user_info: The dependency that check user was authorized     crud: This is the dependency that we created in the previous section.  Returns:     volume
   * @summary Extend Volume
   * @param {VolumeApiExtendVolumeVolumesVolumeIdExtendPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public extendVolumeVolumesVolumeIdExtendPost(
    requestParameters: VolumeApiExtendVolumeVolumesVolumeIdExtendPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .extendVolumeVolumesVolumeIdExtendPost(requestParameters.volumeId, requestParameters.extendVolume, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * There is a function that takes a volume_id as an argument, and returns a serialized volume object. If volume_id doesn\'t come the function will return all serialized volume objects.  Args:     volume_id (Optional[str]): Optional[str] =     Query(None, description=\"Volume id\")     crud: This is the dependency that we created in the previous section.  Returns:     volume
   * @summary Get Volume
   * @param {VolumeApiGetVolumeVolumesVolumeIdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public getVolumeVolumesVolumeIdGet(
    requestParameters: VolumeApiGetVolumeVolumesVolumeIdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .getVolumeVolumesVolumeIdGet(requestParameters.volumeId, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * It gets all volumes from the database  Args:     storage_id: Storage id     free_volumes: parameter if True will return volume without attachments     crud: This is the dependency that we created in the previous section.  Returns:     A list of volumes.
   * @summary Get Volumes
   * @param {VolumeApiGetVolumesVolumesGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VolumeApi
   */
  public getVolumesVolumesGet(
    requestParameters: VolumeApiGetVolumesVolumesGetRequest = {},
    options?: RawAxiosRequestConfig
  ) {
    return VolumeApiFp(this.configuration)
      .getVolumesVolumesGet(
        requestParameters.storageId,
        requestParameters.freeVolumes,
        requestParameters.page,
        requestParameters.size,
        options
      )
      .then(request => request(this.axios, this.basePath))
  }
}
